[
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "假设所有设备的购买日期提前1年，重新计算平均使用寿命。",
        "query": "SELECT AVG(JULIANDAY('now') - JULIANDAY(purchaseDate, '-1 year')) AS avg_lifespan FROM Devices;",
        "type": 4,
        "idx": 2001,
        "englishquestion": "Assuming the purchase date of all devices is advanced by 1 year, recalculate the average service life.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Adjust purchase dates by subtracting 1 year from the original purchaseDate for all devices  【step2】: Calculate the lifespan for each device by finding the difference between the current date (JULIANDAY('now')) and the adjusted purchase date (JULIANDAY(purchaseDate, '-1 year'))  【step3】: Compute the average of all calculated lifespans using the AVG() function"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每类传感器的数据质量分布（高、中、低）。",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceDate < (SELECT installationDate FROM EnergyDevices WHERE EnergyDevices.deviceId = MaintenanceRecords.deviceId);",
        "type": 2,
        "idx": 2002,
        "englishquestion": "Statistics on the data quality distribution (high, medium, low) for each type of sensor.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Retrieve the installationDate for each device from the EnergyDevices table by matching deviceId with MaintenanceRecords.  【step2】: Compare maintenanceDate in MaintenanceRecords with the corresponding installationDate from the subquery.  【step3】: Filter and return records where maintenanceDate is earlier than installationDate."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "识别湿度传感器数据超过100%或低于0%的异常记录。",
        "query": "SELECT * FROM ExperimentData WHERE deviceId IN (SELECT deviceId FROM Devices WHERE deviceType = '湿度传感器') AND (measurementValue > 100 OR measurementValue < 0);",
        "type": 3,
        "idx": 2003,
        "englishquestion": "Identify abnormal records where humidity sensor data exceeds 100% or falls below 0%.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Retrieve all deviceIds from Devices where deviceType is '湿度传感器'.  【step2】: Filter ExperimentData records where deviceId matches the retrieved humidity sensor deviceIds.  【step3】: Apply additional conditions to select records with measurementValue exceeding 100% or below 0%."
    },
    {
        "db_id": "SmartHomeDB",
        "zhongwen": "假设碳排放系数增加50%，计算年度总碳排放量。",
        "query": "SELECT s.sensorType, sd.dataQuality, COUNT(sd.dataId) AS data_count FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType, sd.dataQuality;",
        "type": 4,
        "idx": 2004,
        "englishquestion": "Assuming a 50% increase in the carbon emission coefficient, calculate the total annual carbon emissions.",
        "db_info": "1、'AutomationRules' 表示自动化规则表，记录了智能家居的自动化规则。它的字段：ruleId 表示主键，规则记录的唯一标识符；ruleName 表示规则名称；ruleDescription 表示规则描述；triggerCondition 表示触发条件；action 表示执行动作；deviceId 表示外键，关联设备表的 deviceId；userId 表示外键，关联用户表的 userId；creationDate 表示创建日期；lastModifiedDate 表示最后修改日期；ruleStatus 表示规则状态（启用、禁用）。\n2、'Devices' 表示设备表，记录了智能家居设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型；manufacturerId 表示外键，关联制造商表的 manufacturerId；model 表示设备型号；powerRating 表示功率评级；voltageRating 表示电压评级；installationDate 表示安装日期；status 表示设备状态（在线、离线、故障）；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期。\n3、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n4、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n5、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；supportEmail 表示支持邮箱。\n6、'Notifications' 表示通知表，记录了用户的通知信息。它的字段：notificationId 表示主键，通知记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；notificationType 表示通知类型（维护提醒、异常警报）；notificationMessage 表示通知消息；timestamp 表示时间戳；notificationStatus 表示通知状态（已读、未读）；notificationPriority 表示通知优先级（高、中、低）；notificationSource 表示通知来源（系统、设备）；notificationDescription 表示通知描述。\n7、'SensorData' 表示传感器数据表，记录了传感器采集的数据。它的字段：dataId 表示主键，传感器数据的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；timestamp 表示时间戳；dataValue 表示数据值；dataStatus 表示数据状态（正常、异常）；dataUnit 表示数据单位；dataDescription 表示数据描述；dataSource 表示数据来源；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n8、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；sensorType 表示传感器类型；sensorName 表示传感器名称；unit 表示单位；installationDate 表示安装日期；status 表示传感器状态（正常、故障）；lastCalibrationDate 表示上次校准日期；calibrationInterval 表示校准间隔；sensorDescription 表示传感器描述。\n9、'UserPreferences' 表示用户偏好表，记录了用户的偏好设置。它的字段：preferenceId 表示主键，偏好记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；preferenceName 表示偏好名称；preferenceValue 表示偏好值；timestamp 表示时间戳；preferenceType 表示偏好类型（手动设置、自动学习）；preferenceDescription 表示偏好描述；preferenceSource 表示偏好来源；preferenceQuality 表示偏好质量（高、中、低）。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（管理员、普通用户）。",
        "english_step": "【step1】: Perform JOIN operation between SensorData and Sensors tables to associate sensor readings with their corresponding sensor types and quality indicators.  【step2】: Multiply the original emission factor by 1.5 (50% increase) in the calculation logic, assuming energyConsumed values from EnergyConsumption are used for emission calculations.  【step3】: Aggregate total annual carbon emissions by applying the adjusted coefficient to energy consumption data, filtered by year and grouped by required dimensions."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "计算商品运输的总运费（假设运费为重量×距离×0.5元/公斤公里）。",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "type": 1,
        "idx": 2005,
        "englishquestion": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Access the 'Products' table to retrieve the weight of each product.  【step2】: Calculate the shipping cost for individual products by multiplying weight, distance (implicitly assumed from context), and the rate 0.5.  【step3】: Aggregate all individual shipping costs using SUM() to derive the total_shipping_cost."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个用户的总订单金额，并按金额降序排列。",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "type": 2,
        "idx": 2006,
        "englishquestion": "Count the total order amount for each user and sort in descending order by amount.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select userId and sum totalAmount for each user from Orders table.  【step2】: Group the results by userId to aggregate total spending per user.  【step3】: Order the aggregated results by total_spent in descending sequence."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "找出订单金额为负数或零的记录。",
        "query": "SELECT SUM(p.weight * s.shippingFee * 0.5) AS total_shipping_cost FROM Products p JOIN Shipping s ON p.productId = s.orderId;",
        "type": 3,
        "idx": 2007,
        "englishquestion": "Find records where the order amount is negative or zero.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Access the 'Orders' table to retrieve order records.  【step2】: Apply filter condition WHERE totalAmount <= 0 OR finalAmount <= 0.  【step3】: Return all fields (*) from the filtered orders where the amount is non-positive."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "假设运费率上涨20%，计算总运费。",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "type": 4,
        "idx": 2008,
        "englishquestion": "Assuming a 20% increase in freight rates, calculate the total freight cost.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Identify the original shipping rate (0.6) and apply a 20% increase, resulting in an adjusted rate of 0.6 * 1.2 = 0.72.  【step2】: Calculate the total shipping cost by summing the product of weight, distance, and the adjusted rate (0.72) for all entries in the Products table."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "计算设备的平均维护间隔（单位：天）。",
        "query": "SELECT AVG(JULIANDAY(nextMaintenanceDate) - JULIANDAY(lastMaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "type": 1,
        "idx": 2009,
        "englishquestion": "Calculate the average maintenance interval of the equipment (unit: days).",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Access the 'MaintenanceRecords' table to retrieve 'lastMaintenanceDate' and 'nextMaintenanceDate' for each maintenance record.  【step2】: Calculate the difference in days between 'nextMaintenanceDate' and 'lastMaintenanceDate' for each record using JULIANDAY() to convert dates to Julian day numbers.  【step3】: Compute the average of all calculated day differences using the AVG() function to determine the mean maintenance interval."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个位置的设备数量，并按数量降序排列。",
        "query": "SELECT category AS product_category, COUNT(productId) AS product_count FROM Products GROUP BY category ORDER BY product_count DESC;",
        "type": 2,
        "idx": 2010,
        "englishquestion": "Count the number of devices for each location, and sort them in descending order by quantity.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Group all records in the 'Products' table by the 'category' column.  【step2】: Calculate the number of products in each category using COUNT(productId) and alias the result as 'product_count'.  【step3】: Sort the grouped results in descending order based on the 'product_count' value."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出维护记录中维护日期晚于下次维护日期的矛盾数据。",
        "query": "SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;",
        "type": 3,
        "idx": 2011,
        "englishquestion": "Identify the contradictory data in maintenance records where the maintenance date is later than the next scheduled maintenance date.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Retrieve all records from the MaintenanceRecords table.  【step2】: Apply the filter condition where maintenanceDate is later than nextMaintenanceDate.  【step3】: Return all columns for the conflicting records that meet the criteria."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "假设所有设备的维护间隔缩短50%，重新计算平均维护间隔。",
        "query": "SELECT labId, COUNT(deviceId) AS device_count FROM Devices GROUP BY labId ORDER BY device_count DESC;",
        "type": 4,
        "idx": 2012,
        "englishquestion": "Assuming the maintenance interval for all devices is reduced by 50%, recalculate the average maintenance interval.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Calculate the original average maintenance interval per device by analyzing the time difference between consecutive maintenance dates from MaintenanceRecords table.  【step2】: Apply a 50% reduction to each device's maintenance interval by multiplying the calculated intervals by 0.5.  【step3】: Aggregate the adjusted intervals and compute the final average maintenance interval, grouping by labId if required."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每类设备的故障率（故障次数/使用天数），并按故障率降序排列。",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "type": 2,
        "idx": 2013,
        "englishquestion": "Count the failure rate (number of failures/days of use) for each type of device and sort them in descending order by failure rate.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Calculate maintenance count per deviceType using GROUP BY and COUNT(maintenanceId)  【step2】: Compute usage days per deviceType with JULIANDAY difference between current date and installationDate  【step3】: Derive failure_rate by dividing maintenance count by usage days, then ORDER BY failure_rate DESC"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出设备安装日期在未来的记录。",
        "query": "SELECT * FROM EnergyDevices WHERE installationDate > NOW();",
        "type": 3,
        "idx": 2014,
        "englishquestion": "Identify records where the device installation date is in the future.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Identify the target table \"EnergyDevices\" where installation dates are stored.  【step2】: Apply the filter condition \"installationDate > NOW()\" to select records with future installation dates.  【step3】: Execute the SELECT * query to retrieve all columns from the filtered records."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "假设所有设备的功率增加40%，计算年度总电费。",
        "query": "SELECT e.deviceType, COUNT(m.maintenanceId) / AVG(DATEDIFF(NOW(), e.installationDate)) AS failure_rate FROM MaintenanceRecords m JOIN EnergyDevices e ON m.deviceId = e.deviceId GROUP BY e.deviceType ORDER BY failure_rate DESC;",
        "type": 4,
        "idx": 2015,
        "englishquestion": "Assuming the power of all devices increases by 40%, calculate the total annual electricity cost.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】:JOIN MaintenanceRecords and EnergyDevices using deviceId to associate maintenance records with device information  【step2】:GROUP BY deviceType and calculate failure_rate as (total maintenance count) divided by (average days since installation)  【step3】:ORDER results by calculated failure_rate in descending order to show most failure-prone device types first"
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "计算商品的平均重量（单位：千克）。",
        "query": "SELECT AVG(measurementValue) AS avg_weight FROM ExperimentData WHERE unit = 'kg';",
        "type": 1,
        "idx": 2016,
        "englishquestion": "Calculate the average weight of the products (unit: kilograms).",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Filter ExperimentData records where the unit is 'kg'  【step2】: Calculate the average of the measurementValue column from the filtered records  【step3】: Output the result as avg_weight using column aliasing"
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个商品类别的总销售额，并按销售额降序排列。",
        "query": "SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;",
        "type": 2,
        "idx": 2017,
        "englishquestion": "Count the total sales for each product category and sort them in descending order by sales.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Retrieve all records from the Orders table and group them by the category column.  【step2】: Calculate the sum of totalPrice for each grouped category, aliased as total_sales.  【step3】: Sort the result set in descending order based on the total_sales value."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "找出商品库存为负数或零的记录。",
        "query": "SELECT * FROM Products WHERE stock <= 0;",
        "type": 3,
        "idx": 2018,
        "englishquestion": "Find records where the product inventory is negative or zero.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Access the 'Products' table to retrieve all columns.  【step2】: Apply filter condition `WHERE stock <= 0` to select records with non-positive stock values.  【step3】: (Not required for this simple query. Omitted as per guidelines.)"
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "假设所有商品的重量减少30%，计算运输总重量。",
        "query": "SELECT p.category, SUM(od.quantity * p.weight) AS total_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId GROUP BY p.category ORDER BY total_weight DESC;",
        "type": 4,
        "idx": 2019,
        "englishquestion": "Assuming the weight of all products decreases by 30%, calculate the total transportation weight.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Join OrderDetails and Products tables to associate each ordered product with its weight.  【step2】: Calculate adjusted weight for each product by multiplying original weight (p.weight) by 0.7 (30% reduction), then sum the total adjusted weight per category using SUM(od.quantity * p.weight * 0.7).  【step3】: Group results by product category and sort descendingly by total_weight using GROUP BY p.category and ORDER BY total_weight DESC."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "计算设备的平均保修剩余天数（单位：天）。",
        "query": "SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;",
        "type": 1,
        "idx": 2020,
        "englishquestion": "Calculate the average remaining warranty days for the devices (in days).",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Retrieve warrantyExpiryDate values from Devices table  【step2】: Calculate remaining warranty days for each device by subtracting current date (JULIANDAY('now')) from warranty expiry dates (JULIANDAY(warrantyExpiryDate))  【step3】: Apply AVG() function to all calculated remaining warranty days to get final average"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每个制造商的设备平均维护成本，并按成本降序排列。",
        "query": "SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;",
        "type": 2,
        "idx": 2021,
        "englishquestion": "Statistics on the average maintenance cost of equipment for each manufacturer, sorted in descending order by cost.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Retrieve manufacturerId and cost values from MaintenanceRecords table.  【step2】: Group records by manufacturerId and compute the average maintenance cost using AVG(cost).  【step3】: Sort the grouped results in descending order based on avg_maintenance_cost."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "找出设备状态为'运行中'但未记录维护日期的记录。",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND calibrationDate IS NULL;",
        "type": 3,
        "idx": 2022,
        "englishquestion": "Find records where the device status is 'Running' but no maintenance date is recorded.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Filter records from the Devices table where the status is '运行中'.  【step2】: Apply an additional filter to select records where calibrationDate is NULL from the results of step 1.  【step3】: (Not required for this query, as it involves only two straightforward conditions without joins or sorting.)"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "假设所有设备的保修期延长1年，重新计算平均保修剩余天数。",
        "query": "SELECT maintenanceId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY maintenanceId ORDER BY avg_maintenance_cost DESC;",
        "type": 4,
        "idx": 2023,
        "englishquestion": "Assuming the warranty period for all devices is extended by one year, recalculate the average remaining warranty days.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Calculate the original warranty expiration date for all devices by adding the extended 1 year to their installation dates.  【step2】: Compute the remaining warranty days by finding the difference between the new expiration date and the current date using `DATEDIFF()`.  【step3】: Calculate the average of the remaining warranty days across all devices with `AVG()`."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "统计每类传感器的数据采集频率（单位：次/天），并按频率降序排列。",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;",
        "type": 2,
        "idx": 2024,
        "englishquestion": "Counting the data collection frequency (in units of times/day) for each type of sensor, and sorting them in descending order by frequency.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Select sensorType and dataCollectionFrequency from the Sensors table.  【step2】: Group records by sensorType to aggregate the data collection frequency.  【step3】: Apply ORDER BY dataCollectionFrequency DESC to sort the result."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "识别温度传感器数据超过50℃或低于-20℃的异常记录。",
        "query": "SELECT * FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;",
        "type": 3,
        "idx": 2025,
        "englishquestion": "Identify abnormal records where the temperature sensor data exceeds 50°C or falls below -20°C.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Filter records where temperature exceeds 50°C using `temperature > 50` condition  【step2】: Filter records where temperature falls below -20°C using `temperature < -20` condition  【step3】: Combine both results using `OR` operator to retrieve all abnormal readings"
    },
    {
        "db_id": "SmartHomeDB",
        "zhongwen": "假设碳排放系数增加50%，计算年度总碳排放量。",
        "query": "SELECT sensorId, COUNT(dataId) AS data_frequency FROM SensorData GROUP BY sensorId ORDER BY data_frequency DESC;",
        "type": 4,
        "idx": 2026,
        "englishquestion": "Assuming the carbon emission factor increases by 50%, calculate the total annual carbon emissions.",
        "db_info": "1、'AutomationRules' 表示自动化规则表，记录了智能家居的自动化规则。它的字段：ruleId 表示主键，规则记录的唯一标识符；ruleName 表示规则名称；ruleDescription 表示规则描述；triggerCondition 表示触发条件；action 表示执行动作；deviceId 表示外键，关联设备表的 deviceId；userId 表示外键，关联用户表的 userId；creationDate 表示创建日期；lastModifiedDate 表示最后修改日期；ruleStatus 表示规则状态（启用、禁用）。\n2、'Devices' 表示设备表，记录了智能家居设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型；manufacturerId 表示外键，关联制造商表的 manufacturerId；model 表示设备型号；powerRating 表示功率评级；voltageRating 表示电压评级；installationDate 表示安装日期；status 表示设备状态（在线、离线、故障）；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期。\n3、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n4、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n5、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；supportEmail 表示支持邮箱。\n6、'Notifications' 表示通知表，记录了用户的通知信息。它的字段：notificationId 表示主键，通知记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；notificationType 表示通知类型（维护提醒、异常警报）；notificationMessage 表示通知消息；timestamp 表示时间戳；notificationStatus 表示通知状态（已读、未读）；notificationPriority 表示通知优先级（高、中、低）；notificationSource 表示通知来源（系统、设备）；notificationDescription 表示通知描述。\n7、'SensorData' 表示传感器数据表，记录了传感器采集的数据。它的字段：dataId 表示主键，传感器数据的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；timestamp 表示时间戳；dataValue 表示数据值；dataStatus 表示数据状态（正常、异常）；dataUnit 表示数据单位；dataDescription 表示数据描述；dataSource 表示数据来源；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n8、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；sensorType 表示传感器类型；sensorName 表示传感器名称；unit 表示单位；installationDate 表示安装日期；status 表示传感器状态（正常、故障）；lastCalibrationDate 表示上次校准日期；calibrationInterval 表示校准间隔；sensorDescription 表示传感器描述。\n9、'UserPreferences' 表示用户偏好表，记录了用户的偏好设置。它的字段：preferenceId 表示主键，偏好记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；preferenceName 表示偏好名称；preferenceValue 表示偏好值；timestamp 表示时间戳；preferenceType 表示偏好类型（手动设置、自动学习）；preferenceDescription 表示偏好描述；preferenceSource 表示偏好来源；preferenceQuality 表示偏好质量（高、中、低）。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（管理员、普通用户）。",
        "english_step": "【step1】: Calculate annual total energy consumption from EnergyConsumption table by summing energyConsumed values filtered by year.  【step2】: Apply 50% increased emission coefficient (original coefficient ×1.5) to the total energy value.  【step3】: Return the final result as annual_total_carbon_emission."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "计算商品运输的总运费（假设运费为重量×距离×0.5元/公斤公里）。",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "type": 1,
        "idx": 2027,
        "englishquestion": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Retrieve the weight and (assumed) distance values for each product from the **Products** table.  【step2】: Multiply each product's weight by its distance and the rate 0.5 to compute individual shipping costs.  【step3】: Aggregate all individual shipping costs using the **SUM** function to calculate the total shipping cost."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个用户的总订单金额，并按金额降序排列。",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "type": 2,
        "idx": 2028,
        "englishquestion": "Calculate the total order amount for each user and sort them in descending order by amount.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select userId and sum totalAmount for each user using SUM(totalAmount) with GROUP BY userId.  【step2】: Alias the summed totalAmount as total_spent to represent the aggregated spending per user.  【step3】: Order the results by total_spent in descending order using ORDER BY total_spent DESC."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "找出订单状态为'已完成'但未支付成功的记录。",
        "query": "SELECT SUM(weight * price * 0.5) AS total_shipping_cost FROM Products;",
        "type": 3,
        "idx": 2029,
        "englishquestion": "Find records where the order status is 'Completed' but the payment was not successful.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Retrieve all product records' weight and price columns from Products table  【step2】: Calculate temporary shipping cost for each product using (weight × price × 0.5)  【step3】: Aggregate results by summing all temporary values into total_shipping_cost alias"
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "假设运费率上涨20%，计算总运费。",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "type": 4,
        "idx": 2030,
        "englishquestion": "Assuming a 20% increase in freight rates, calculate the total freight cost.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Adjust the original shipping rate (0.6) by 20%, resulting in a new rate of 0.72 (0.6 * 1.2).  【step2】: Calculate shipping costs for each product by multiplying weight, distance, and the adjusted rate (weight * distance * 0.72).  【step3】: Aggregate all individual shipping costs using SUM() to produce the total_shipping_cost."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "计算设备的平均维护间隔（单位：天）。",
        "query": "SELECT AVG(DATEDIFF(paymentDate, orderDate)) AS avg_payment_interval FROM Payments JOIN Orders ON Payments.orderId = Orders.orderId;",
        "type": 1,
        "idx": 2031,
        "englishquestion": "Calculate the average maintenance interval for devices (unit: days).",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Join the 'Payments' and 'Orders' tables using the orderId to link payment records with corresponding order dates.  【step2】: Calculate the day difference between paymentDate (from Payments) and orderDate (from Orders) for each matched record using DATEDIFF().  【step3】: Compute the average of all calculated day intervals using AVG() to get the final metric."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个位置的设备数量，并按数量降序排列。",
        "query": "SELECT address, COUNT(*) AS device_count FROM Manufacturers GROUP BY address ORDER BY device_count DESC;",
        "type": 2,
        "idx": 2032,
        "englishquestion": "Count the number of devices per location and sort them in descending order by quantity.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select the 'address' field and count records from the 'Manufacturers' table.  【step2】: Group the results by the 'address' field to calculate the number of devices per location.  【step3】: Sort the grouped results in descending order based on the calculated device count."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出维护记录中维护日期晚于下次维护日期的矛盾数据。",
        "query": "SELECT * FROM MaintenanceRecords WHERE DATEDIFF(nextMaintenanceDate, maintenanceDate) < 0;",
        "type": 3,
        "idx": 2033,
        "englishquestion": "Find contradictory data in maintenance records where the maintenance date is later than the next scheduled maintenance date.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Retrieve all maintenance records from the MaintenanceRecords table.  【step2】: Calculate the date difference between nextMaintenanceDate and maintenanceDate for each record using the DATEDIFF function.  【step3】: Filter records where the calculated date difference is negative, indicating maintenanceDate occurs after nextMaintenanceDate."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "假设所有设备的维护间隔缩短50%，重新计算平均维护间隔。",
        "query": "SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;",
        "type": 4,
        "idx": 2034,
        "englishquestion": "Assuming the maintenance interval for all devices is reduced by 50%, recalculate the average maintenance interval.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Calculate original average maintenance interval per device using MaintenanceRecords by finding datediff between consecutive maintenance dates  【step2】: Multiply each device's average interval by 0.5 to simulate 50% reduction  【step3】: Group results by locationId from Devices table and calculate final averaged reduced intervals"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每类设备的故障率（故障次数/使用天数），并按故障率降序排列。",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "type": 2,
        "idx": 2035,
        "englishquestion": "Statistics of the failure rate (number of failures/days in use) for each type of equipment, sorted in descending order by failure rate.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: [Join MaintenanceRecords with EnergyDevices using deviceId to access deviceType and installationDate for each maintenance record]  【step2】: [Group by deviceType, calculate total maintenance count per group and average usage days (current_date - installationDate)]  【step3】: [Compute failure_rate (count/days), then sort results by failure_rate descending]"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出设备安装日期在未来的记录。",
        "query": "SELECT * FROM EnergyDevices WHERE installationDate > CURRENT_DATE;",
        "type": 3,
        "idx": 2036,
        "englishquestion": "Find records where the equipment installation date is in the future.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】:【Retrieve all columns from the EnergyDevices table】  【step2】:【Filter records where installationDate is greater than the current date using the condition installationDate > CURRENT_DATE】  【step3】:【(No additional steps required; the query does not involve joins, subqueries, or sorting)】"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "假设所有设备的功率增加40%，计算年度总电费。",
        "query": "SELECT d.deviceType, SUM(e.energyConsumed * d.powerRating * 1.4 * 365 * 24) AS annualElectricityCost FROM EnergyConsumption e JOIN EnergyDevices d ON e.deviceId = d.deviceId GROUP BY d.deviceType ORDER BY annualElectricityCost DESC;",
        "type": 4,
        "idx": 2037,
        "englishquestion": "Assuming the power of all devices increases by 40%, calculate the total annual electricity cost.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Join EnergyConsumption and EnergyDevices tables via deviceId to link consumption data with device power ratings.  【step2】: Calculate annual electricity cost per device type using (energyConsumed × powerRating × 1.4 × 24 × 365), then aggregate with SUM grouped by deviceType.  【step3】: Sort results in descending order by the calculated annualElectricityCost."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "计算商品的平均重量（单位：千克）。",
        "query": "SELECT AVG(weightKg) AS avgWeight FROM Devices;",
        "type": 1,
        "idx": 2038,
        "englishquestion": "Calculate the average weight of the products (unit: kilograms).",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Retrieve the weightKg column from the Devices table containing all device weight records in kilograms.  【step2】: Calculate the average value of the weightKg column using the AVG() aggregation function and alias the result as avgWeight."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个商品类别的总销售额，并按销售额降序排列。",
        "query": "SELECT category, SUM(totalPrice) AS total_sales FROM Orders GROUP BY category ORDER BY total_sales DESC;",
        "type": 2,
        "idx": 2039,
        "englishquestion": "Count the total sales for each product category and sort them in descending order by sales.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select category and totalPrice columns from Orders table  【step2】: Group records by category and calculate sum of totalPrice as total_sales  【step3】: Sort results in descending order by total_sales"
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "找出商品库存为负数或零的记录。",
        "query": "SELECT * FROM Products WHERE stock <= 0;",
        "type": 3,
        "idx": 2040,
        "englishquestion": "Find records where the product inventory is negative or zero.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select all columns from the Products table.  【step2】: Apply the filter condition to retain records where the stock value is less than or equal to 0."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "假设所有商品的重量减少30%，计算运输总重量。",
        "query": "SELECT SUM(p.weight * od.quantity * 0.7) AS total_shipping_weight FROM OrderDetails od JOIN Products p ON od.productId = p.productId;",
        "type": 4,
        "idx": 2041,
        "englishquestion": "Assuming the weight of all goods is reduced by 30%, calculate the total transportation weight.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Join OrderDetails with Products using productId to access each product's weight and ordered quantity.  【step2】: Calculate adjusted shipping weight per item by reducing original weight by 30% (multiply by 0.7) and multiply by ordered quantity.  【step3】: Aggregate results using SUM() to get the total shipping weight across all order details."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "计算设备的平均保修剩余天数（单位：天）。",
        "query": "SELECT AVG(JULIANDAY(warrantyExpiryDate) - JULIANDAY('now')) AS avg_warranty_remaining FROM Devices;",
        "type": 1,
        "idx": 2042,
        "englishquestion": "Calculate the average remaining warranty days of the equipment (unit: days).",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Calculate remaining warranty days per device using JULIANDAY() function  【step2】: Apply AVG() aggregate function to compute average  【step3】: Alias the result column as avg_warranty_remaining"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每个制造商的设备平均维护成本，并按成本降序排列。",
        "query": "SELECT manufacturerId, AVG(cost) AS avg_maintenance_cost FROM MaintenanceRecords GROUP BY manufacturerId ORDER BY avg_maintenance_cost DESC;",
        "type": 2,
        "idx": 2043,
        "englishquestion": "Statistics on the average maintenance cost of equipment for each manufacturer, sorted in descending order by cost.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Retrieve manufacturerId and maintenance cost values from the MaintenanceRecords table.  【step2】: Group the records by manufacturerId and compute the average maintenance cost using AVG(cost).  【step3】: Sort the grouped results in descending order based on the calculated average maintenance cost."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "找出设备状态为'运行中'但未记录维护日期的记录。",
        "query": "SELECT * FROM Devices WHERE status = '运行中' AND lastMaintenanceDate IS NULL;",
        "type": 3,
        "idx": 2044,
        "englishquestion": "Find records where the equipment status is 'running' but no maintenance date has been recorded.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Filter all records from the Devices table where the status is '运行中'.  【step2】: Further restrict the results to include only records where lastMaintenanceDate is NULL."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "假设所有设备的保修期延长1年，重新计算平均保修剩余天数。",
        "query": "SELECT deviceId, DATEDIFF(DATE_ADD(installationDate, INTERVAL 1 YEAR), CURRENT_DATE) AS remaining_warranty_days FROM EnergyDevices;",
        "type": 4,
        "idx": 2045,
        "englishquestion": "Assuming the warranty period for all devices is extended by 1 year, recalculate the average remaining warranty days.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Extend warranty period by 1 year using DATE_ADD on installationDate.  【step2】: Calculate remaining days using DATEDIFF between adjusted warranty date and current date.  【step3】: Aggregate results with AVG to compute the average remaining warranty days."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "统计每类传感器的数据采集频率（单位：次/天），并按频率降序排列。",
        "query": "SELECT sensorType, AVG(dataCollectionFrequency) AS avgFrequency FROM Sensors GROUP BY sensorType ORDER BY avgFrequency DESC;",
        "type": 2,
        "idx": 2046,
        "englishquestion": "Statistics on the data collection frequency (unit: times/day) for each type of sensor, sorted in descending order by frequency.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Group sensor records by sensorType  【step2】: Calculate average dataCollectionFrequency per group  【step3】: Sort results by avgFrequency in descending order"
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "识别温度传感器数据超过50℃或低于-20℃的异常记录。",
        "query": "SELECT sensorId, recordedAt, temperature FROM TemperatureReadings WHERE temperature > 50 OR temperature < -20;",
        "type": 3,
        "idx": 2047,
        "englishquestion": "Identify abnormal records where the temperature sensor data exceeds 50°C or falls below -20°C.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Retrieve sensorId, recordedAt, and temperature columns from TemperatureReadings table  【step2】: Filter records where temperature exceeds 50°C using the condition **temperature > 50**  【step3】: Combine with records where temperature falls below -20°C via **OR temperature < -20** to capture both anomaly thresholds"
    },
    {
        "db_id": "SmartHomeDB",
        "zhongwen": "假设碳排放系数增加50%，计算年度总碳排放量。",
        "query": "SELECT s.sensorType, COUNT(sd.dataId) AS data_frequency FROM SensorData sd JOIN Sensors s ON sd.sensorId = s.sensorId GROUP BY s.sensorType ORDER BY data_frequency DESC;",
        "type": 4,
        "idx": 2048,
        "englishquestion": "Assuming the carbon emission factor increases by 50%, calculate the total annual carbon emissions.",
        "db_info": "1、'AutomationRules' 表示自动化规则表，记录了智能家居的自动化规则。它的字段：ruleId 表示主键，规则记录的唯一标识符；ruleName 表示规则名称；ruleDescription 表示规则描述；triggerCondition 表示触发条件；action 表示执行动作；deviceId 表示外键，关联设备表的 deviceId；userId 表示外键，关联用户表的 userId；creationDate 表示创建日期；lastModifiedDate 表示最后修改日期；ruleStatus 表示规则状态（启用、禁用）。\n2、'Devices' 表示设备表，记录了智能家居设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型；manufacturerId 表示外键，关联制造商表的 manufacturerId；model 表示设备型号；powerRating 表示功率评级；voltageRating 表示电压评级；installationDate 表示安装日期；status 表示设备状态（在线、离线、故障）；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期。\n3、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n4、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n5、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；supportEmail 表示支持邮箱。\n6、'Notifications' 表示通知表，记录了用户的通知信息。它的字段：notificationId 表示主键，通知记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；notificationType 表示通知类型（维护提醒、异常警报）；notificationMessage 表示通知消息；timestamp 表示时间戳；notificationStatus 表示通知状态（已读、未读）；notificationPriority 表示通知优先级（高、中、低）；notificationSource 表示通知来源（系统、设备）；notificationDescription 表示通知描述。\n7、'SensorData' 表示传感器数据表，记录了传感器采集的数据。它的字段：dataId 表示主键，传感器数据的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；timestamp 表示时间戳；dataValue 表示数据值；dataStatus 表示数据状态（正常、异常）；dataUnit 表示数据单位；dataDescription 表示数据描述；dataSource 表示数据来源；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n8、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；sensorType 表示传感器类型；sensorName 表示传感器名称；unit 表示单位；installationDate 表示安装日期；status 表示传感器状态（正常、故障）；lastCalibrationDate 表示上次校准日期；calibrationInterval 表示校准间隔；sensorDescription 表示传感器描述。\n9、'UserPreferences' 表示用户偏好表，记录了用户的偏好设置。它的字段：preferenceId 表示主键，偏好记录的唯一标识符；userId 表示外键，关联用户表的 userId；deviceId 表示外键，关联设备表的 deviceId；preferenceName 表示偏好名称；preferenceValue 表示偏好值；timestamp 表示时间戳；preferenceType 表示偏好类型（手动设置、自动学习）；preferenceDescription 表示偏好描述；preferenceSource 表示偏好来源；preferenceQuality 表示偏好质量（高、中、低）。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（管理员、普通用户）。",
        "english_step": "【step1】: Join SensorData and Sensors tables on sensorId to associate sensor readings with their types.  【step2】: Group records by sensorType and count dataId occurrences using COUNT() to get data frequency per type.  【step3】: Sort the grouped results in descending order of calculated data_frequency using ORDER BY."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "计算商品运输的总运费（假设运费为重量×距离×0.5元/公斤公里）。",
        "query": "SELECT SUM(weight * distance * 0.5) AS total_shipping_cost FROM Products;",
        "type": 1,
        "idx": 2049,
        "englishquestion": "Calculate the total shipping cost for the goods (assuming the shipping cost is weight × distance × 0.5 yuan per kilogram-kilometer).",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Retrieve all product records from the 'Products' table, including the **weight** field required for calculation.  【step2】: Calculate the shipping cost for each product using the formula *weight × distance × 0.5*. Assume **distance** is implicitly available (even though it is not explicitly defined in the provided schema).  【step3】: Aggregate all individual shipping costs with the **SUM()** function to return the final **total_shipping_cost**."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个用户的总订单金额，并按金额降序排列。",
        "query": "SELECT userId, SUM(totalAmount) AS total_spent FROM Orders GROUP BY userId ORDER BY total_spent DESC;",
        "type": 2,
        "idx": 2050,
        "englishquestion": "Count the total order amount for each user and sort them in descending order by amount.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select userId and totalAmount from the Orders table.  【step2】: Group the results by userId and calculate the sum of totalAmount for each user using SUM(totalAmount) AS total_spent.  【step3】: Order the grouped results in descending order based on total_spent using ORDER BY total_spent DESC."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "找出订单状态为'已完成'但未支付成功的记录。",
        "query": "SELECT * FROM Orders WHERE orderStatus = '已完成' AND orderId NOT IN (SELECT orderId FROM Payments WHERE paymentStatus = '成功');",
        "type": 3,
        "idx": 2051,
        "englishquestion": "Find records where the order status is 'Completed' but the payment was not successful.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Filter all orders with status 'Completed' from Orders table using WHERE orderStatus = 'Completed'  【step2】: Retrieve orderIDs from Payments table where payment was successful via subquery (SELECT orderId FROM Payments WHERE paymentStatus = 'Success')  【step3】: Exclude completed orders that appear in successful payment records using NOT IN operator on the subquery results"
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "假设运费率上涨20%，计算总运费。",
        "query": "SELECT SUM(weight * distance * 0.6) AS total_shipping_cost FROM Products;",
        "type": 4,
        "idx": 2052,
        "englishquestion": "Assuming a 20% increase in freight rates, calculate the total freight cost.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Calculate the new shipping rate by increasing the original rate (0.6) by 20%, resulting in 0.6 * 1.2 = 0.72.  【step2】: Compute individual shipping costs for each product using the updated rate: weight * distance * 0.72.  【step3】: Aggregate all individual shipping costs with SUM() to produce the total_shipping_cost."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "计算设备的平均维护间隔（单位：天）。",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, maintenanceDate)) AS avg_maintenance_interval FROM Orders WHERE maintenanceDate IS NOT NULL AND nextMaintenanceDate IS NOT NULL;",
        "type": 1,
        "idx": 2053,
        "englishquestion": "Calculate the average maintenance interval of the equipment (unit: days).",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Filter valid maintenance records by checking non-null maintenanceDate and nextMaintenanceDate in Orders table.  【step2】: Calculate the day difference between nextMaintenanceDate and maintenanceDate for each valid record using DATEDIFF().  【step3】: Compute the average of these calculated intervals using AVG() function to get the final result."
    },
    {
        "db_id": "ECommerce",
        "zhongwen": "统计每个位置的设备数量，并按数量降序排列。",
        "query": "SELECT category, COUNT(*) AS device_count FROM Products GROUP BY category ORDER BY device_count DESC;",
        "type": 2,
        "idx": 2054,
        "englishquestion": "Count the number of devices at each location and sort in descending order by quantity.",
        "db_info": "1、'Discounts' 表示折扣表，记录了商品的折扣信息。它的字段：discountId 表示主键，折扣记录的唯一标识符；productId 表示外键，关联商品表的 productId；discountType 表示折扣类型（百分比折扣、固定金额折扣）；discountValue 表示折扣值；startDate 表示折扣开始日期；endDate 表示折扣结束日期；maxUsage 表示最大使用次数；currentUsage 表示当前使用次数；status 表示折扣状态（启用、禁用）；description 表示折扣描述；creationDate 表示创建日期。\n2、'Manufacturers' 表示制造商表，记录了商品制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。\n3、'OrderDetails' 表示订单详情表，记录了订单中商品的详细信息。它的字段：detailId 表示主键，订单详情的唯一标识符；orderId 表示外键，关联订单表的 orderId；productId 表示外键，关联商品表的 productId；quantity 表示购买数量；unitPrice 表示单价；totalPrice 表示总价；discount 表示折扣金额；tax 表示税费；shippingFee 表示运费；status 表示订单状态（已发货、已收货）；deliveryDate 表示交付日期。\n4、'Orders' 表示订单表，记录了订单的基本信息。它的字段：orderId 表示主键，订单的唯一标识符；userId 表示外键，关联用户表的 userId；orderDate 表示订单日期；totalAmount 表示订单总金额；shippingAddress 表示配送地址；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；orderStatus 表示订单状态（待支付、已发货、已完成）；shippingFee 表示运费；tax 表示税费；discount 表示折扣金额；finalAmount 表示最终金额；maintenanceDate 表示维护日期；nextMaintenanceDate 表示下次维护日期。\n5、'Payments' 表示支付表，记录了订单的支付信息。它的字段：paymentId 表示主键，支付记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；paymentDate 表示支付日期；paymentMethod 表示支付方式（信用卡、支付宝、微信支付）；amount 表示支付金额；transactionId 表示交易ID；paymentStatus 表示支付状态（成功、失败）；currency 表示货币类型（人民币、美元）；payerName 表示付款人姓名；payerEmail 表示付款人邮箱；payerPhone 表示付款人电话。\n6、'Products' 表示商品表，记录了商品的基本信息。它的字段：productId 表示主键，商品的唯一标识符；productName 表示商品名称；description 表示商品描述；price 表示商品价格；stock 表示库存数量；category 表示商品类别；weight 表示商品重量；volume 表示商品体积；manufacturerId 表示外键，关联制造商表的 manufacturerId；creationDate 表示创建日期；status 表示商品状态（上架、下架）。\n7、'Returns' 表示退货表，记录了订单的退货信息。它的字段：returnId 表示主键，退货记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；userId 表示外键，关联用户表的 userId；returnDate 表示退货日期；returnReason 表示退货原因；returnStatus 表示退货状态（待处理、已退款）；returnAmount 表示退款金额；returnMethod 表示退款方式（原路返回、银行转账）；shippingFee 表示运费；description 表示描述；approvalDate 表示批准日期。\n8、'Reviews' 表示评价表，记录了用户对商品的评价信息。它的字段：reviewId 表示主键，评价记录的唯一标识符；userId 表示外键，关联用户表的 userId；productId 表示外键，关联商品表的 productId；rating 表示评分；reviewText 表示评价内容；reviewDate 表示评价日期；helpfulNotes 表示有用票数；unhelpfulNotes 表示无用票数；status 表示评价状态（已审核、未审核）；reviewTitle 表示评价标题；reviewerName 表示评价者姓名。\n9、'Shipping' 表示物流表，记录了订单的物流信息。它的字段：shippingId 表示主键，物流记录的唯一标识符；orderId 表示外键，关联订单表的 orderId；shippingMethod 表示物流方式（快递、物流）；shippingDate 表示发货日期；estimatedDeliveryDate 表示预计送达日期；actualDeliveryDate 表示实际送达日期；shippingStatus 表示物流状态（已发送、已签收）；trackingNumber 表示物流跟踪号；shippingAddress 表示配送地址；shippingFee 表示运费；carrierName 表示承运商名称。\n10、'Users' 表示用户表，记录了用户的基本信息。它的字段：userId 表示主键，用户的唯一标识符；userName 表示用户名；email 表示电子邮件；passwordHash 表示密码哈希值；phone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；registrationDate 表示注册日期；lastLoginDate 表示上次登录日期；userRole 表示用户角色（普通用户、管理员）。",
        "english_step": "【step1】: Select the 'category' column and count all records for each category using COUNT(*) function.  【step2】: Group the results by the 'category' column to aggregate device counts.  【step3】: Sort the grouped results in descending order based on the calculated 'device_count' values."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出维护记录中维护日期晚于下次维护日期的矛盾数据。",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "type": 3,
        "idx": 2055,
        "englishquestion": "Find contradictory data in the maintenance records where the maintenance date is later than the next scheduled maintenance date.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Filter records from MaintenanceRecords where maintenanceDate should logically precede nextMaintenanceDate.  【step2】: Apply condition WHERE maintenanceDate > nextMaintenanceDate to detect chronological contradictions.  【step3】: Return conflicting entries with SELECT * FROM MaintenanceRecords WHERE maintenanceDate > nextMaintenanceDate;."
    },
    {
        "db_id": "PhysicsLabDB",
        "zhongwen": "假设所有设备的维护间隔缩短50%，重新计算平均维护间隔。",
        "query": "SELECT locationId, COUNT(deviceId) AS device_count FROM Devices GROUP BY locationId ORDER BY device_count DESC;",
        "type": 4,
        "idx": 2056,
        "englishquestion": "Assuming the maintenance intervals for all devices are reduced by 50%, recalculate the average maintenance interval.",
        "db_info": "1、'Calculations' 表示计算表，记录了实验中的计算结果。它的字段：calculationId 表示主键，计算记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；formula 表示计算公式；inputData 表示输入数据；result 表示计算结果；unit 表示单位；dataQuality 表示数据质量（高、中、低）。\n2、'Constraints' 表示约束表，记录了实验中的约束条件。它的字段：constraintId 表示主键，约束记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；constraintText 表示约束条件文本；constraintType 表示约束类型（等式、不等式）；dataQuality 表示数据质量（高、中、低）。\n3、'DeviceTypes' 表示设备类型表，记录了设备类型及其维护成本。它的字段：deviceType 表示主键，设备类型的唯一标识符；maintenanceCost 表示维护成本。\n4、'Devices' 表示设备表，记录了实验室设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（光密仪、其他）；calibrationDate 表示校准日期；status 表示设备状态（正常、故障）；labId 表示外键，关联实验室表的 labId；supplierId 表示外键，关联供应商表的 supplierId；warrantyEndDate 表示保修结束日期；purchaseDate 表示购买日期；itemName 表示物品名称；specifications 表示规格；storageLocation 表示存储位置；flemId 表示外键；placeId 表示外键；serialNumber 表示序列号；warrantyPeriod 表示保修期；energyConsumption 表示能耗；power 表示功率；powerRating 表示功率评级；current 表示电流；installationDate 表示安装日期；locationId 表示外键；weightKg 表示重量（千克）；lastMaintenanceDate 表示上次维护日期，itemId 表示物品的唯一标识符。\n5、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：deviceId 表示外键，关联设备表的 deviceId；energyConsumed 表示能耗值；consumptionDate 表示能耗记录日期。\n6、'ExperimentData' 表示实验数据表，记录了实验中的数据。它的字段：dataId 表示主键，实验数据的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；measurementValue 表示测量值；unit 表示单位；dataQuality 表示数据质量（高、中、低）；environmentalConditions 表示环境条件。\n7、'Experiments' 表示实验表，记录了实验的基本信息。它的字段：experimentId 表示主键，实验的唯一标识符；experimentName 表示实验名称；description 表示实验描述；startDate 表示实验开始日期；endDate 表示实验结束日期；status 表示实验状态（进行中、已完成）；hypothesis 表示假设；objective 表示实验目标；researcherId 表示外键，关联研究员表的 researcherId；labId 表示外键，关联实验室表的 labId。\n8、'Hypotheses' 表示假设表，记录了实验中的假设。它的字段：hypothesisId 表示主键，假设的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'Labs' 表示实验室表，记录了实验室的基本信息。它的字段：labId 表示主键，实验室的唯一标识符；labName 表示实验室名称；location 表示实验室位置；capacity 表示实验室容量；equipmentCount 表示设备数量；status 表示实验室状态（开放、关闭）。\n10、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；description 表示维护描述。\n11、'Places' 表示地点表，记录了地点的基本信息。它的字段：placeId 表示主键，地点的唯一标识符；country 表示国家。\n12、'Researchers' 表示研究员表，记录了研究员的基本信息。它的字段：researcherId 表示主键，研究员的唯一标识符；researcherName 表示研究员姓名；email 表示电子邮件；phone 表示联系电话；department 表示部门；role 表示角色（实验员、数据分析师）；joinDate 表示加入日期。\n13、'SensitivityAnalysis' 表示敏感性分析表，记录了实验中的敏感性分析结果。它的字段：analysisId 表示主键，敏感性分析记录的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableId 表示外键，关联变量表的 variableId；sensitivityValue 表示敏感性值；impact 表示影响程度（高、中、低）；dataQuality 表示数据质量（高、中、低）。\n14、'Sensors' 表示传感器表，记录了传感器的基本信息。它的字段：sensorId 表示主键，传感器的唯一标识符；sensorType 表示传感器类型；dataCollectionFrequency 表示数据采集频率（单位：次/天）。\n15、'Suppliers' 表示供应商表，记录了供应商的基本信息。它的字段：supplierId 表示主键，供应商的唯一标识符；supplierName 表示供应商名称；contactInfo 表示联系信息。\n16、'TemperatureReadings' 表示温度记录表，记录了传感器的温度读数。它的字段：recordId 表示主键，温度记录的唯一标识符；sensorId 表示外键，关联传感器表的 sensorId；recordedAt 表示记录时间；temperature 表示温度值。\n17、'Variables' 表示变量表，记录了实验中的变量信息。它的字段：variableId 表示主键，变量的唯一标识符；experimentId 表示外键，关联实验表的 experimentId；variableName 表示变量名称；initialValue 表示初始值；unit 表示单位；dataQuality 表示数据质量（高、中、低）。",
        "english_step": "【step1】: Calculate original average maintenance intervals per device using MaintenanceRecords (time difference between consecutive maintenance dates)  【step2】: Apply 50% reduction to each device's average interval (multiply by 0.5)  【step3】: Compute final global average of adjusted maintenance intervals across all devices"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "统计每类设备的故障率（故障次数/使用天数），并按故障率降序排列。",
        "query": "SELECT deviceType, COUNT(maintenanceId) / (JULIANDAY('now') - JULIANDAY(installationDate)) AS failure_rate FROM MaintenanceRecords GROUP BY deviceType ORDER BY failure_rate DESC;",
        "type": 2,
        "idx": 2057,
        "englishquestion": "Count the failure rate (number of failures / days in use) for each type of equipment, and sort in descending order by failure rate.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Calculate the number of maintenance records (failure count) per deviceType using COUNT(maintenanceId) with GROUP BY deviceType.  【step2】: Compute usage days for each deviceType by subtracting installationDate from the current date using JULIANDAY functions.  【step3】: Derive failure_rate by dividing failure count by usage days, then order results by failure_rate in descending order."
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "找出设备安装日期在未来的记录。",
        "query": "SELECT AVG(DATEDIFF(nextMaintenanceDate, MaintenanceDate)) AS avg_maintenance_interval FROM MaintenanceRecords;",
        "type": 3,
        "idx": 2058,
        "englishquestion": "Identify records where the device installation date is in the future.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Filter records from EnergyDevices where installationDate > CURDATE() to select devices with future installation dates  【step2】: Select deviceId and installationDate from the filtered results  【step3】: Return final list of devices (all columns) satisfying this temporal condition"
    },
    {
        "db_id": "EnergyManagementDB",
        "zhongwen": "假设所有设备的功率增加40%，计算年度总电费。",
        "query": "SELECT ed.deviceId, ed.deviceName, ed.powerRating * 1.4 AS newPowerRating, SUM(ec.energyConsumed) AS totalEnergyConsumed, (SUM(ec.energyConsumed) * 1.4 * 0.1) AS annualElectricityCost FROM EnergyDevices ed JOIN EnergyConsumption ec ON ed.deviceId = ec.deviceId WHERE YEAR(ec.timestamp) = YEAR(CURDATE()) GROUP BY ed.deviceId, ed.deviceName;",
        "type": 4,
        "idx": 2059,
        "englishquestion": "Assuming all devices' power increases by 40%, calculate the total annual electricity cost.",
        "db_info": "1、'EnergyAudits' 表示能源审计表，记录了设备的能源审计信息。它的字段：auditId 表示主键，审计记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；auditDate 表示审计日期；auditorName 表示审计员姓名；auditResult 表示审计结果（合格、不合格）；recommendations 表示建议；dataQuality 表示数据质量（高、中、低）。\n2、'EnergyConsumption' 表示能耗记录表，记录了设备的能耗情况。它的字段：consumptionId 表示主键，能耗记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；energyConsumed 表示能耗值；powerUsage 表示功率使用量；voltage 表示电压；current 表示电流；temperature 表示温度；humidity 表示湿度；dataQuality 表示数据质量（高、中、低）。\n3、'EnergyDevices' 表示能源设备表，记录了能源设备的基本信息。它的字段：deviceId 表示主键，设备的唯一标识符；deviceName 表示设备名称；deviceType 表示设备类型（太阳能、风能、化石燃料）；powerRating 表示功率评级；efficiency 表示效率；installationDate 表示安装日期；status 表示设备状态（运行中、维护中、停用）；location 表示设备位置；manufacturerId 表示外键，关联制造商表的 manufacturerId；lastMaintenanceDate 表示上次维护日期；nextMaintenanceDate 表示下次维护日期；humidity 表示湿度；voltage 表示电压；current 表示电流。\n4、'EnergyEfficiency' 表示能源效率表，记录了设备的能源效率信息。它的字段：efficiencyId 表示主键，效率记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；efficiency 表示效率；energySaved 表示节省的能源；costSavings 表示节省的成本；dataQuality 表示数据质量（高、中、低）。\n5、'EnergyForecasts' 表示能源预测表，记录了设备的能源预测信息。它的字段：forecastId 表示主键，预测记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；forecastType 表示预测类型（能耗预测、发电量预测）；forecastValue 表示预测值；confidenceLevel 表示置信水平；dataQuality 表示数据质量（高、中、低）。\n6、'EnergyPolicies' 表示能源政策表，记录了能源政策的基本信息。它的字段：policyId 表示主键，政策的唯一标识符；policyName 表示政策名称；description 表示政策描述；effectiveDate 表示生效日期；expiryDate 表示失效日期；targetEfficiency 表示目标效率；targetCarbonFootprint 表示目标碳足迹；status 表示政策状态（启用、禁用）。\n7、'EnvironmentalImpact' 表示环境影响表，记录了设备的环境影响信息。它的字段：impactId 表示主键，环境影响记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；timestamp 表示时间戳；carbonFootprint 表示碳足迹；energySource 表示能源来源（太阳能、风能、化石燃料）；pollutionLevel 表示污染水平；waterUsage 表示用水量；landUsage 表示土地使用量；dataQuality 表示数据质量（高、中、低）。\n8、'Hypotheses' 表示假设表，记录了设备相关的假设信息。它的字段：hypothesisId 表示主键，假设的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；hypothesisText 表示假设文本；status 表示假设状态（已验证、未验证）；verificationDate 表示验证日期；verificationResult 表示验证结果（真、假）；dataQuality 表示数据质量（高、中、低）。\n9、'MaintenanceRecords' 表示维护记录表，记录了设备的维护信息。它的字段：maintenanceId 表示主键，维护记录的唯一标识符；deviceId 表示外键，关联设备表的 deviceId；maintenanceDate 表示维护日期；maintenanceType 表示维护类型（定期维护、紧急维修）；technicianName 表示技术员姓名；technicianContact 表示技术员联系方式；cost 表示维护成本；partsReplaced 表示更换的零件；maintenanceDescription 表示维护描述；nextMaintenanceDate 表示下次维护日期。\n10、'Manufacturers' 表示制造商表，记录了设备制造商的基本信息。它的字段：manufacturerId 表示主键，制造商的唯一标识符；manufacturerName 表示制造商名称；contactPerson 表示联系人；contactEmail 表示联系邮箱；contactPhone 表示联系电话；address 表示地址；city 表示城市；country 表示国家；website 表示官方网站；revenue 表示营业额；profit 表示利润。",
        "english_step": "【step1】: Join EnergyDevices and EnergyConsumption tables using deviceId, filter records from current calendar year using YEAR(timestamp)=YEAR(CURDATE()).  【step2】: Calculate new power ratings (original powerRating × 1.4) and aggregate total energyConsumed per device using SUM().  【step3】: Compute annual electricity cost by multiplying total energyConsumed with scaled power (×1.4) and electricity rate (×0.1), grouped by deviceId/deviceName."
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id , strftime ( \"%Y\" , date_became_customer ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_became_customer ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Customers",
        "englishquestion": "List the IDs of customers and their ages when they signed up for the driving school.",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Extract the customer_id, calculate the raw age difference by subtracting the customer's birth year from the registration year.  【step2】: Adjust for incomplete years by checking if the registration month-day is earlier than the birth month-day using DATE_FORMAT comparisons.  【step3】: Subtract the adjustment (0 or 1) from the raw age difference to get the precise signup age.",
        "type": 3,
        "idx": 2060
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id , strftime ( \"%Y\" , date_became_customer ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_became_customer ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Customers",
        "englishquestion": "Give me IDs of all customers and their ages at the time of registering for driving school?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Extract the customer_id and calculate the preliminary age by subtracting the birth year from the registration year (YEAR(date_became_customer) - YEAR(date_of_birth)).  【step2】: Adjust the age calculation by checking if the birthdate anniversary occurred before registration date using DATE_FORMAT comparisons on month-day values.  【step3】: Subtract 1 year from the preliminary age when registration month-day comes before birth month-day, finalizing the accurate registration age.",
        "type": 3,
        "idx": 2061
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = \"Dameon\" AND last_name = \"Sanford\") UNION ALL SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", \"2001-01-01\") - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", \"2001-01-01\")) AS age FROM Customers WHERE first_name = \"Dameon\" AND last_name = \"Sanford\"",
        "englishquestion": "If Damon Sanford was born on the first day of the 21st century, list the customer IDs and their ages when they signed up for the driving school.",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date. The 21st century began on 1st January 2001.",
        "english_step": "【step1】: Filter out customers named 'Dameon Sanford', calculate their signup age using their actual date_of_birth.  【step2】: Select 'Dameon Sanford' specifically, calculate his age using the fixed birthdate '2001-01-01'.  【step3】: Combine both results with UNION ALL to include all customers with correct age calculations.",
        "type": 4,
        "idx": 2062
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", date_of_birth)) AS age FROM Customers WHERE NOT (first_name = \"Dameon\" AND last_name = \"Sanford\") UNION ALL SELECT customer_id, strftime (\"%Y\", date_became_customer) - strftime (\"%Y\", \"2001-01-01\") - (strftime (\"%m-%d\", date_became_customer) < strftime (\"%m-%d\", \"2001-01-01\")) AS age FROM Customers WHERE first_name = \"Dameon\" AND last_name = \"Sanford\"",
        "englishquestion": "Give me IDs of all customers and their ages when registering for driving school if Damon Sanford was born on the first day of the 21st Century.",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date. The 21st century began on 1st January 2001.",
        "english_step": "【step1】: Calculate age for non-Dameon Sanford customers by subtracting birth year from registration year, adjusting for unpassed birthdays via DATE_FORMAT comparison.  【step2】: Handle Dameon Sanford separately by fixing his birth year to 2001 and checking if registration occurred before Jan 1st to adjust age.  【step3】: Combine both results using UNION ALL to include all customers while excluding Dameon Sanford from the first subset.",
        "type": 4,
        "idx": 2063
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )",
        "englishquestion": "What percentage of customers with outstanding amounts larger than 2000 are good customers?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of \"Good Customers\" (those with amount_outstanding > 2000 AND customer_status_code = 'Good Customer') using a subquery with COUNT(*).  【step2】: Calculate the total number of customers with amount_outstanding > 2000 (regardless of status) using another subquery with COUNT(*).  【step3】: Cross-join the two subquery results and compute the percentage via 100.0 * good / n to avoid integer division.",
        "type": 2,
        "idx": 2064
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM Customers WHERE amount_outstanding > 2000 )",
        "englishquestion": "Give me the percentage of customers with over 2000 in outstanding balance who are rated good?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of \"Good Customer\" entries meeting the criteria using the subquery: `SELECT COUNT(*) AS good FROM Customers WHERE amount_outstanding > 2000 AND customer_status_code = 'Good Customer'`.  【step2】: Calculate the total number of customers with outstanding balances over 2000 using the subquery: `SELECT COUNT(*) AS n FROM Customers WHERE amount_outstanding > 2000`.  【step3】: Combine results via cross-join and compute the percentage with `100.0 * good / n AS percent` to ensure floating-point division.",
        "type": 2,
        "idx": 2065
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 )",
        "englishquestion": "If all customers who registered in 2015 have an outstanding amount of 200, what percentage of customers with outstanding amounts greater than 2000 are good customers?",
        "reasoning_type": "* / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a temporary dataset (sub1/sub2) by combining 2015-registered customers (with forced amount_outstanding=200) and other customers (retaining original values) via UNION ALL.  【step2】: Calculate the numerator (good) by filtering the temporary dataset for entries where amount_outstanding > 2000 AND customer_status_code = 'Good Customer'.  【step3】: Calculate the denominator (n) by filtering the same temporary dataset for entries where amount_outstanding > 2000, then compute the percentage via (good / n) * 100.0.",
        "type": 4,
        "idx": 2066
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * good / n AS percent FROM ( SELECT COUNT ( * ) AS good FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n FROM ( SELECT 200 AS amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) = \"2015\" UNION ALL SELECT amount_outstanding , customer_status_code FROM Customers WHERE strftime ( \"%Y\" , date_became_customer ) != \"2015\" ) WHERE amount_outstanding > 2000 )",
        "englishquestion": "What percentage of customers are rated good with an outstanding balance of over 2000 if all customers registered in 2015 have an outstanding amount over 2000?",
        "reasoning_type": "* / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a combined dataset (subquery1/subquery2) where all customers registered in 2015 have their amount_outstanding forced to 200 (contradicting the problem's premise), while retaining original data for others.  【step2】: Calculate two values separately:  - **good**: Count customers with amount_outstanding > 2000 and status 'Good Customer' from the combined dataset.  - **n**: Count all customers with amount_outstanding > 2000 from the same dataset.  【step3】: Compute the percentage using `100.0 * good / n` by joining the two intermediate results.",
        "type": 4,
        "idx": 2067
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "englishquestion": "List the ID and number of lessons scheduled for staffs who were older than 20 when they joined the driving school.",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Filter staff members who were older than 20 when joining by calculating age as (YEAR(date_joined_staff) - YEAR(date_of_birth)) adjusted with a CASE statement for birthday occurrence, then join with Lessons to count scheduled lessons per staff_id using GROUP BY.  【step2】: Select qualifying staff with no lessons by checking staff_ids not in the joined Lessons table, assigning 0 as n_lesson.  【step3】: Combine both results (staffs with lessons and staffs without lessons) using UNION ALL to ensure all eligible staff are included in the final output.",
        "type": 3,
        "idx": 2068
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM Staff WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "englishquestion": "Give me the ID and number of scheduled lessons for all staff older than age 20 at the time of joining the driving school.",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the age of each staff member at the time of joining using `TIMESTAMPDIFF(YEAR, date_of_birth, date_joined_staff)` and adjust for birthdate/month-day comparison to filter staff older than 20.  【step2】: For staff matching the age criteria, join the `Staff` and `Lessons` tables to count scheduled lessons via `COUNT(*)` grouped by `staff_id`.  【step3】: Use `UNION ALL` to combine results with staff from the age-filtered group who have no lessons (detected via `NOT IN` subquery on Lessons-connected staff), assigning `0` as `n_lesson`.",
        "type": 3,
        "idx": 2069
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "englishquestion": "If the staffs who resigned on March 8th, 2018 all joined on March 8th, 2016, list the IDs and number of lessons scheduled for staffs who were older than 20 when they joined.",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Create a combined dataset (A) by selecting staff who left on 2018-03-08 (with joined date forced to 2016-03-08) and other staff with their original joined dates via UNION ALL.  【step2】: Calculate staff age-at-joining for dataset A and join with Lessons to count scheduled lessons for staff aged >20. Simultaneously, create dataset C (same as A), identify staff aged >20 with ZERO lessons via NOT IN subquery against Lessons.  【step3】: Combine results from step 2 (staff with lessons) and step 2's sub-result (staff without lessons) using UNION ALL to finalize IDs and lesson counts.",
        "type": 4,
        "idx": 2070
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id, COUNT (*) AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) A JOIN Lessons B ON A.staff_id = B.staff_id WHERE strftime (\"%Y\", A.date_joined_staff) - strftime (\"%Y\", A.date_of_birth) - (strftime (\"%m-%d\", A.date_joined_staff) < strftime (\"%m-%d\", A.date_of_birth)) > 20 UNION ALL SELECT staff_id, 0 AS n_lesson FROM (SELECT staff_id, date_of_birth, \"2016-03-08\" AS date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) = \"2018-03-08\" UNION ALL SELECT staff_id, date_of_birth, date_joined_staff FROM Staff WHERE strftime (\"%Y-%m-%d\", date_left_staff) != \"2018-03-08\" ) WHERE strftime (\"%Y\", date_joined_staff) - strftime (\"%Y\", date_of_birth) - (strftime (\"%m-%d\", date_joined_staff) < strftime (\"%m-%d\", date_of_birth)) > 20 AND staff_id NOT IN (SELECT A.staff_id FROM Staff A JOIN Lessons B ON A.staff_id = B.staff_id)",
        "englishquestion": "Give me the ID and quantity of scheduled lessons for all staff older than age 20 at the time of commencing employment at the driving school if all staff who joined on March 8 2016 resigned on March 8 2018.",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Create a derived table `A` combining staff who resigned on 2018-03-08 (with enforced `date_joined_staff`=2016-03-08) and staff with other resignation dates (using original `date_joined_staff`), including birth dates.  【step2】: Calculate staff's age at employment using `YEAR(date_joined_staff) - YEAR(date_of_birth) - (date_of_birth day/month > date_joined_staff day/month)`, filter those older than 20. Join with `Lessons` to count scheduled lessons.  【step3】: Use `UNION ALL` to combine: 1) staff with lessons count from step 2, and 2) staff meeting age criteria but having no lessons (using `staff_id NOT IN` subquery to detect staff without lesson matches).",
        "type": 4,
        "idx": 2071
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1",
        "englishquestion": "What's the ID of staff who has worked at the driving school the longest?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Calculate the duration each staff member has worked using DATEDIFF(date_left_staff, date_joined_staff).  【step2】: Order the results by this calculated duration in descending order.  【step3】: Limit the output to the top result to retrieve the staff_id with the longest tenure.",
        "type": 3,
        "idx": 2072
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id FROM Staff ORDER BY julianday ( date_left_staff ) - julianday ( date_joined_staff ) DESC LIMIT 1",
        "englishquestion": "Tell me the ID of staff who have worked at the driving school the longest?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Calculate the duration each staff has worked by using DATEDIFF(date_left_staff, date_joined_staff) to find the difference in days between their join and leave dates.  【step2】: Order the results in descending order based on the calculated duration to prioritize the longest-working staff.  【step3】: Retrieve the staff_id of the top result using LIMIT 1 to get the staff with the maximum duration.",
        "type": 3,
        "idx": 2073
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id FROM (SELECT staff_id, strftime (\"%Y-%m-%d\", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1",
        "englishquestion": "If Lincoln Benny Carroll joined on his 21st birthday, list the ID of the staff who has worked at the driving school the longest? ",
        "reasoning_type": "- + * C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time. Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the adjusted `date_joined_staff` for Lincoln Benny Carroll by adding 21 years (approximated via 21*365.25 days) to his `date_of_birth`, while retaining original `date_joined_staff` for other staff via a subquery.  【step2】: Combine Lincoln's modified record with all other staff records using `UNION ALL`, creating a unified dataset with derived/raw join dates and original leave dates.  【step3】: Order all staff by total working duration (`DATEDIFF(date_left_staff, date_joined_staff)`) in descending order and select the top result’s `staff_id` using `LIMIT 1`.",
        "type": 4,
        "idx": 2074
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id FROM (SELECT staff_id, strftime (\"%Y-%m-%d\", julianday (date_of_birth) + 21 * 365.25) AS date_joined_staff, date_left_staff FROM Staff WHERE first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\" UNION ALL SELECT staff_id, date_joined_staff, date_left_staff FROM Staff WHERE NOT (first_name = \"Lincoln\" AND middle_name = \"Benny\" AND last_name = \"Carroll\") ) ORDER BY julianday (date_left_staff) - julianday (date_joined_staff) DESC LIMIT 1",
        "englishquestion": "What's the ID of the staff member who has worked at the driving school longest if Lincoln Benny Carroll joined on their 21st birthday?",
        "reasoning_type": "- + * C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time. Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate Lincoln Benny Carroll's adjusted \"date_joined_staff\" as their 21st birthday using DATE_ADD and DATE_FORMAT, while keeping original dates for other staff members.  【step2】: Combine Lincoln's modified record with other staff records through UNION ALL, creating a merged dataset with consistent date_joined_staff/date_left_staff columns.  【step3】: Calculate employment duration using DATEDIFF(date_left_staff, date_joined_staff), sort descending by duration, and select the top result with LIMIT 1.",
        "type": 4,
        "idx": 2075
    },
    {
        "db_id": "school",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "englishquestion": "Among the customers who have never attended a class, how much more bad customers than good customers?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter customers who never attended a non-cancelled class using `customer_id NOT IN (SELECT DISTINCT customer_id FROM Lessons WHERE lesson_status_code != 'Cancelled')`.  【step2】: Calculate two counts separately:  - `n_good` by adding `customer_status_code = 'Good Customer'`  - `n_bad` by adding `customer_status_code = 'Bad Customer'`  【step3】: Compute the difference between bad and good customer counts via `n_bad - n_good AS diff` using JOIN on the two subqueries.",
        "type": 2,
        "idx": 2076
    },
    {
        "db_id": "school",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM Lessons WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "englishquestion": "How many more customers are rated bad than good for only the customers who have never attended a class?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify customers who have never attended a non-cancelled class by filtering Customers with customer_id NOT IN (SELECT DISTINCT customer_id FROM Lessons WHERE lesson_status_code != 'Cancelled').  【step2】: Calculate the count of \"Good Customer\" (n_good) and \"Bad Customer\" (n_bad) separately from the filtered customer list using two subqueries.  【step3】: Compute the difference (diff) between n_bad and n_good by joining the results of the subqueries through a CROSS JOIN and performing arithmetic subtraction.",
        "type": 2,
        "idx": 2077
    },
    {
        "db_id": "school",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "englishquestion": "Assuming that all classes are not canceled on March 7, 2018, how much more bad customers than good customers among the customers who have never attended a class?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify customers who have never attended any non-cancelled classes by excluding those who appear in the union dataset (combining 2018-03-07 completed lessons and non-cancelled lessons from other dates).  【step2】: Count \"Good Customer\" and \"Bad Customer\" separately from the filtered customer pool using two subqueries with customer_status_code filters.  【step3】: Calculate the arithmetic difference between bad customer count (n_bad) and good customer count (n_good) using JOIN on the two subquery results.",
        "type": 4,
        "idx": 2078
    },
    {
        "db_id": "school",
        "query": "SELECT n_bad - n_good AS diff FROM ( SELECT COUNT ( * ) AS n_good FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Good Customer\" ) JOIN ( SELECT COUNT ( * ) AS n_bad FROM Customers WHERE customer_id NOT IN ( SELECT DISTINCT ( customer_id ) FROM ( SELECT customer_id , \"Completed\" AS lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) = \"2018-03-07\" UNION ALL SELECT customer_id , lesson_status_code FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) != \"2018-03-07\" ) WHERE lesson_status_code != \"Cancelled\" ) AND customer_status_code = \"Bad Customer\" )",
        "englishquestion": "How many more customers are rated bad than good for only the customers who have never attended a class if all classes were not canceled on March 7 2018?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify customers who have never attended any non-cancelled classes by excluding those who appear in the union of: 1) March 7, 2018 classes treated as 'Completed', and 2) non-March 7 classes with original statuses except 'Cancelled'.  【step2】: Count 'Good Customer' and 'Bad Customer' statuses separately within this filtered group using two subqueries (t1 for good, t2 for bad).  【step3】: Calculate the difference between bad and good counts by subtracting t1.n_good from t2.n_bad using a JOIN between the two subqueries.",
        "type": 4,
        "idx": 2079
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "englishquestion": "How much is the average course fee for a staff who has no course schedule after March 5, 2018? What's his staff ID and how old is he this year?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve all `staff_id` values from the `Lessons` table where `lesson_date` is after March 5, 2018, using a subquery in the `WHERE` clause.  【step2】: Join the `Lessons` and `Staff` tables on `staff_id`, filtering out staff who appear in the subquery results (i.e., exclude those with lessons after March 5, 2018).  【step3】: Group the remaining records by `staff_id`, calculate the average course fee (`AVG(price)`), and compute age using date arithmetic based on `date_of_birth` and the current year.",
        "type": 3,
        "idx": 2080
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "englishquestion": "Tell me the staff ID, average course fee, and age (this year) for staff with no course scheduled after 5 March 2018?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve staff IDs who have lessons scheduled after '2018-03-05' using a subquery: `SELECT staff_id FROM Lessons WHERE DATE(lesson_date) > '2018-03-05'`.  【step2】: Join the **Lessons** and **Staff** tables, filtering out staff IDs from the subquery. Calculate age using date_of_birth and current date.  【step3】: Compute the average course fee (AVG(price)) for the remaining staff and group results by staff_id to finalize the output.",
        "type": 3,
        "idx": 2081
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) = \"2018-02\" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) != \"2018-02\" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "englishquestion": "If the prices of all courses were increased by 8% in February 2018, how much is the average course fee for a staff who has no course schedule after March 5, 2018? What's his staff ID and how old is he this year?",
        "reasoning_type": "* + - C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate adjusted course prices for February 2018 (8% increase) and combine with unchanged prices from other months using UNION ALL, creating temporary table A.  【step2】: Join table A with Staff table to get birthdates, filter out staff with lessons after 2018-03-05 via subquery in WHERE clause.  【step3】: Group results by staff_id, compute average price, and calculate precise age using TIMESTAMPDIFF with birthday adjustment logic.",
        "type": 4,
        "idx": 2082
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) AS avg_price , strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , B.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , B.date_of_birth ) ) AS age FROM ( SELECT staff_id , ( 1 + 0.08 ) * price AS price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) = \"2018-02\" UNION ALL SELECT staff_id , price FROM Lessons WHERE strftime ( \"%Y-%m\" , lesson_date ) != \"2018-02\" ) A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id NOT IN ( SELECT staff_id FROM Lessons WHERE strftime ( \"%Y-%m-%d\" , lesson_date ) > \"2018-03-05\" ) GROUP BY A.staff_id",
        "englishquestion": "What is the staff ID, average course fee, and age this year, for staff with no course scheduled after March 5 2018 if all course prices were increased by 8% in February 2018?",
        "reasoning_type": "* + - C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate adjusted course prices by increasing February 2018 course fees by 8% (using UNION ALL to combine adjusted Feb prices with unchanged prices from other months).  【step2】: Filter out staff who have lessons scheduled after March 5, 2018 via NOT IN subquery on the original Lessons table.  【step3】: Join the adjusted price data with Staff table to calculate age, then group by staff_id to compute average course fee and final age calculation using birthdate comparison.",
        "type": 4,
        "idx": 2083
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1",
        "englishquestion": "What's the ID of the coach who has the highest average course price and how much higher than that of the coach with the lowest average course price?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average course price for each coach by grouping lessons data and joining with the staff table.  【step2】: Use a subquery to find the lowest average course price among all coaches.  【step3】: Compute the difference between the highest and lowest average prices, then sort and limit to return the coach with the maximum average price and their price difference.",
        "type": 2,
        "idx": 2084
    },
    {
        "db_id": "school",
        "query": "SELECT A.staff_id , AVG ( A.price ) - ( SELECT AVG ( price ) FROM Lessons GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id GROUP BY A.staff_id ORDER BY AVG ( A.price ) DESC LIMIT 1",
        "englishquestion": "Tell me the ID of the coach who has the highest average course price and how much more does this cost than the average price from the coach with the lowest average price?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average price for each coach, then find the lowest average price via a subquery: `(SELECT AVG(price) FROM Lessons GROUP BY staff_id ORDER BY AVG(price) ASC LIMIT 1)`.  【step2】: Join the `Lessons` and `Staff` tables, group by `staff_id`, compute each coach's average price, and subtract the lowest average (from step 1) to get the difference (`diff`).  【step3】: Order the results by average price in descending order and limit to the top result, returning the coach's ID and the calculated price difference.",
        "type": 2,
        "idx": 2085
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1",
        "englishquestion": "If all courses offered by Winnifred Liam Jast were reduced by 12%, what's the ID of the coach who has the highest average course price and how much higher than that of the coach with the lowest average course price?",
        "reasoning_type": "- * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Adjust prices for Winnifred Liam Jast's courses by 12% reduction and combine with unchanged prices of other coaches using UNION ALL.  【step2】: Calculate each coach's average price from the combined dataset, then determine the minimum average price via subquery.  【step3】: Identify the coach with the maximum average price, compute the difference from the minimum average, and return the staff_id with the highest value and the calculated difference.",
        "type": 4,
        "idx": 2086
    },
    {
        "db_id": "school",
        "query": "SELECT staff_id , AVG ( price ) - ( SELECT AVG ( price ) FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) ASC LIMIT 1 ) AS diff FROM ( SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price * ( 1 - 0.12 ) AS price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" UNION ALL SELECT A.staff_id , B.first_name , B.middle_name , B.last_name , A.price FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE NOT ( B.first_name = \"Winnifred\" AND B.middle_name = \"Liam\" AND B.last_name = \"Jast\" ) ) GROUP BY staff_id ORDER BY AVG ( price ) DESC LIMIT 1",
        "englishquestion": "Tell me the ID of the coach who has the highest average price of a course and how much more this is than the price of a course from the coach with the lowest average price if courses from Winnifred Liam Jast were 12% cheaper?",
        "reasoning_type": "- * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a union dataset where Winnifred's course prices are reduced by 12% while other coaches' prices remain unchanged.  【step2】: Calculate average prices per coach, identify the coach with the highest average price, and simultaneously compute their average price.  【step3】: Subtract the lowest average price (from a parallel calculation filtering Winnifred's adjusted prices and others) from the highest average price to get the difference.",
        "type": 4,
        "idx": 2087
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "englishquestion": "What percentage of clients have multiple coaches?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify clients with multiple coaches by grouping lessons on customer_id and filtering those with at least 2 distinct staff_ids.  【step2】: Calculate the total number of clients in the Customers table.  【step3】: Compute the percentage by dividing the count from step1 by the total from step2 and scaling by 100.0.",
        "type": 2,
        "idx": 2088
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM Lessons GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "englishquestion": "Calculate the percentage of clients with more than one coach?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify clients with multiple coaches by grouping the `Lessons` table by `customer_id` and filtering those with ≥2 distinct `staff_id` using `HAVING COUNT(DISTINCT staff_id) >= 2`.  【step2】: Count the number of clients from step 1 (via `COUNT(*)` on the subquery result).  【step3】: Calculate the percentage by dividing the result from step 2 by the total number of clients in `Customers` and multiplying by 100.0.",
        "type": 2,
        "idx": 2089
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = \"Winnifred\" AND middle_name = \"Liam\" AND last_name = \"Jast\" ) AS staff_id FROM Lessons WHERE lesson_id = \"12\" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != \"12\" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "englishquestion": "If the coach of the course with ID 12 is Winnifred Liam Jast, what percentage of clients have multiple coaches?",
        "reasoning_type": "* / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the customer_id and the specific staff_id (Winnifred Liam Jast) for lesson_id 12, while fetching customer_id and their actual staff_id from other lessons.  【step2】: Combine both datasets using UNION ALL, then group by customer_id to count distinct staff_ids per client.  【step3】: Filter clients with ≥2 distinct staff_ids, calculate their count, and divide by the total number of customers to determine the percentage.",
        "type": 4,
        "idx": 2090
    },
    {
        "db_id": "school",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customers ) AS percent FROM ( SELECT customer_id FROM ( SELECT customer_id , ( SELECT staff_id FROM Staff WHERE first_name = \"Winnifred\" AND middle_name = \"Liam\" AND last_name = \"Jast\" ) AS staff_id FROM Lessons WHERE lesson_id = \"12\" UNION ALL SELECT customer_id , staff_id FROM Lessons WHERE lesson_id != \"12\" ) GROUP BY customer_id HAVING COUNT ( DISTINCT ( staff_id ) ) >= 2 )",
        "englishquestion": "Calculate the percentage of clients with more than a single coach if course with ID 12 is coached by Winnifred Liam Jast.",
        "reasoning_type": "* / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the staff_id of 'Winnifred Liam Jast' and combine lesson records: The innermost subquery fetches the staff_id for the specified coach and creates a unified dataset of all lessons, replacing the coach for lesson_id 12 with this staff_id.  【step2】: Group customers by distinct coaches: The middle subquery groups combined lesson records by customer_id, counting clients with ≥2 distinct staff_id (coaches) via HAVING COUNT(DISTINCT staff_id) >= 2.  【step3】: Calculate percentage: The outer query divides the count of qualifying clients by the total Customers table count, multiplying by 100.0 to return the final percentage.",
        "type": 4,
        "idx": 2091
    },
    {
        "db_id": "school",
        "query": "SELECT strftime ( \"%Y\" , MAX ( date_of_birth ) ) - strftime ( \"%Y\" , MIN ( date_of_birth ) ) - ( strftime ( \"%m-%d\" , MAX ( date_of_birth ) ) < strftime ( \"%m-%d\" , MIN ( date_of_birth ) ) ) AS diff FROM Staff",
        "englishquestion": "How many years older is the oldest staff than the youngest staff?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Extract the maximum (oldest) and minimum (youngest) date_of_birth values from the Staff table using MAX() and MIN() functions.  【step2】: Calculate the difference in birth years between the oldest and youngest staff by subtracting YEAR(MIN(date_of_birth)) from YEAR(MAX(date_of_birth)).  【step3】: Adjust for incomplete years by checking if the month-day of the oldest date_of_birth is earlier than the youngest, using DATE_FORMAT comparisons, and subtract 1 if true to get the accurate age difference.",
        "type": 3,
        "idx": 2092
    },
    {
        "db_id": "school",
        "query": "SELECT strftime ( \"%Y\" , MAX ( date_of_birth ) ) - strftime ( \"%Y\" , MIN ( date_of_birth ) ) - ( strftime ( \"%m-%d\" , MAX ( date_of_birth ) ) < strftime ( \"%m-%d\" , MIN ( date_of_birth ) ) ) AS diff FROM Staff",
        "englishquestion": "Calculate the difference in age between the oldest and youngest staff?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Retrieve the maximum and minimum date_of_birth values from the Staff table using MAX(date_of_birth) and MIN(date_of_birth).  【step2】: Calculate the year difference between these two dates by subtracting YEAR(MIN()) from YEAR(MAX()).  【step3】: Adjust for month-day comparison: subtract 1 if the month-day of MAX(date_of_birth) is earlier than MIN(date_of_birth), using DATE_FORMAT comparisons.",
        "type": 3,
        "idx": 2093
    },
    {
        "db_id": "school",
        "query": "SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" ) ) ORDER BY date_of_birth DESC",
        "englishquestion": "If Camylle Icie Weissnat's age in 2020 is twice that of a person born in 2009, how many years older is the oldest staff than the youngest staff?",
        "reasoning_type": "* - C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Calculate Camylle's virtual birth year (1998) using the age condition: 2020 - (2020 - 2009)*2.  【step2】: Combine Camylle's calculated birth year with other staff's actual birth years via UNION ALL.  【step3】: Compute the age difference between the oldest (MIN(date_of_birth)) and youngest (MAX(date_of_birth)) in the merged dataset.",
        "type": 4,
        "idx": 2094
    },
    {
        "db_id": "school",
        "query": "SELECT MAX ( date_of_birth ) - MIN ( date_of_birth ) AS diff FROM ( SELECT 2020 - ( 2020 - 2009 ) * 2 AS date_of_birth FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" UNION ALL SELECT date_of_birth FROM Staff WHERE NOT ( first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" ) ) ORDER BY date_of_birth DESC",
        "englishquestion": "Calculate the difference in age between the oldest and youngest staff, if in 2020, Camylle Icie Weissnat was twice as old as someone born in 2009.",
        "reasoning_type": "* - C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Calculate Camylle's birth year based on the condition that in 2020, she was twice as old as someone born in 2009 (2020 - 2009 = 11 → 2×11 = 22 → 2020 - 22 = 1998).  【step2】: Create a combined dataset using UNION ALL, including Camylle's derived birth year (1998) and actual birth years of other staff members.  【step3】: Compute the difference between the maximum and minimum values in the combined dataset to get the age gap.",
        "type": 4,
        "idx": 2095
    },
    {
        "db_id": "school",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = \"Cancelled\" )",
        "englishquestion": "What is the total number of courses arranged for the oldest coach when leaving the driving school, and what percentage of them were canceled?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify the oldest coach by calculating their age based on date_left_staff and date_of_birth, then retrieve their staff_id via a subquery.  【step2】: Count the total lessons (total) and canceled lessons (n_cancel) for this staff_id in separate subqueries on the Lessons table.  【step3】: Compute the cancellation ratio by dividing n_cancel by total in the main SELECT statement.",
        "type": 2,
        "idx": 2096
    },
    {
        "db_id": "school",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons WHERE staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND lesson_status_code = \"Cancelled\" )",
        "englishquestion": "What is the sum total of scheduled courses for the oldest coach when leaving the driving school and how many of these were cancelled?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify the oldest coach by calculating their age using date_of_birth and date_left_staff, then retrieve their staff_id via a subquery.  【step2】: Calculate the total number of scheduled courses (total) and the number of cancelled courses (n_cancel) for this coach using two separate subqueries filtered by the identified staff_id.  【step3】: Combine the results from the subqueries and compute the cancellation ratio (n_cancel / total) in the main SELECT statement.",
        "type": 2,
        "idx": 2097
    },
    {
        "db_id": "school",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = \"Cancelled\" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )",
        "englishquestion": "If all coaches have no course scheduled within 60 days after joining, what is the total number of courses arranged for the oldest coach when leaving the driving school, and what percentage of them were canceled?",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify the oldest coach by calculating age using date_left_staff and date_of_birth, then select their staff_id via a subquery ordered by age descending with LIMIT 1.  【step2】: Calculate total courses (t1) for this coach where lesson_date occurs >60 days after their join date (via DATE_ADD), filtered by the staff_id from step1.  【step3】: Compute canceled courses (t2) with the same staff_id and date filter, adding lesson_status_code='Cancelled', then join t1 and t2 to calculate the cancellation ratio.",
        "type": 4,
        "idx": 2098
    },
    {
        "db_id": "school",
        "query": "SELECT total, 1.0 * n_cancel / total AS ratio FROM ( SELECT COUNT ( * ) AS total FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) ) JOIN ( SELECT COUNT ( * ) AS n_cancel FROM Lessons A JOIN Staff B ON A.staff_id = B.staff_id WHERE A.staff_id = ( SELECT staff_id FROM Staff ORDER BY strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) DESC LIMIT 1 ) AND A.lesson_status_code = \"Cancelled\" AND A.lesson_date > strftime ( julianday ( B.date_joined_staff ) + 60 ) )",
        "englishquestion": "Give me the total number of arranged courses, and the cancellation rate, for the oldest coach when leaving the driving school if all coaches have no course scheduled within 60 days after joining.",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify the oldest coach by calculating age via `TIMESTAMPDIFF` adjusted for day/month comparison, then extract their `staff_id` via subquery.  【step2】: Compute total arranged courses (`total`) by counting all lessons for this coach occurring >60 days after their join date (`DATE_ADD`).  【step3】: Calculate cancellation count (`n_cancel`) for the same coach and timeframe, then combine results to derive cancellation rate (`1.0 * n_cancel / total`).",
        "type": 4,
        "idx": 2099
    },
    {
        "db_id": "school",
        "query": "SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id",
        "englishquestion": "What's the ID of the customer who paid the most, and how much more than the customer who paid the least?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the minimum payment amount from Customer_Payments using a subquery.  【step2】: Join Customer_Payments with Customers, group by customer_id, and determine the maximum payment for each customer.  【step3】: Subtract the overall minimum payment (from step1) from each customer's maximum payment to compute payment_diff, then display the customer_id and payment_diff.",
        "type": 2,
        "idx": 2100
    },
    {
        "db_id": "school",
        "query": "SELECT A.customer_id , MAX ( A.amount_payment ) - ( SELECT MIN ( amount_payment ) FROM Customer_Payments ) AS payment_diff FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id",
        "englishquestion": "Tell me the ID of the customer who paid the highest fee and how much more was this than the customer paying the lowest fee?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join Customer_Payments (A) with Customers (B) to ensure valid customer records.  【step2】: Find the highest payment amount (MAX(A.amount_payment)) and its corresponding customer_id.  【step3】: Calculate the difference by subtracting the globally lowest payment (via subquery MIN) from the highest payment.",
        "type": 2,
        "idx": 2101
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )",
        "englishquestion": "If Amya Spinka paid 5000 more on March 12th, 2018, what's the ID of the customer who paid the most, and how much more than the customer who paid the least?",
        "reasoning_type": "- + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Adjust Amya Spinka's payment on 2018-03-12 by adding 5000, and create a dataset combining this adjusted payment with all others (also increased by 5000 for non-Amya or non-2018-03-12 records) via UNION ALL.  【step2】: Build the combined_data temporary table containing all payments after the 5000 adjustment.  【step3】: Calculate the maximum adjusted payment, subtract the minimum adjusted payment from the combined_data, and retrieve the customer_id associated with the maximum payment.",
        "type": 4,
        "idx": 2102
    },
    {
        "db_id": "school",
        "query": "SELECT customer_id, MAX (amount_payment) - (SELECT MIN (amount_payment) FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )) AS payment_diff FROM (SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\" UNION ALL SELECT A.customer_id, amount_payment + 5000 AS amount_payment FROM Customer_Payments A JOIN Customers B ON A.customer_id = B.customer_id WHERE NOT (B.first_name = \"Amya\" AND B.last_name = \"Spinka\" AND strftime (\"%Y-%m-%d\", A.datetime_payment) = \"2018-03-12\") )",
        "englishquestion": "Tell me the ID of the customer who paid the highest fee and how much more was this than the customer paying the lowest fee if Amya Spinka paid 5000 more on 12 March 2018?",
        "reasoning_type": "- + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Adjust payments for Amya Spinka's 2018-03-12 record by adding 5000 via JOIN with Customers table and filter by name/date.  【step2】: Adjust all other payments (non-Amya or non-2018-03-12) by 5000 using the same JOIN, then UNION ALL with step 1's result to create a combined dataset.  【step3】: Calculate the difference between the MAX(adjusted_payment) and MIN(adjusted_payment) from the combined dataset, while selecting the customer_id associated with the highest payment.",
        "type": 4,
        "idx": 2103
    },
    {
        "db_id": "school",
        "query": "SELECT AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Lake Elaina\"",
        "englishquestion": "What is the average age of the coaches living in Lake Elaine, Georgia?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the Staff table (aliased as A) with the Addresses table (aliased as B) using the staff_address_id and address_id to link coach records with their addresses.  【step2】: Filter the combined dataset to retain only coaches located in \"Lake Elaina, Georgia\" using the conditions B.state_province_county = 'Georgia' AND B.city = 'Lake Elaina'.  【step3】: Calculate the average age of these filtered coaches by computing the difference between the current year and their birth year (with adjustment for month/day comparison using DATE_FORMAT), then apply the AVG() function.",
        "type": 3,
        "idx": 2104
    },
    {
        "db_id": "school",
        "query": "SELECT AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Lake Elaina\"",
        "englishquestion": "For the coaches resident in Lake Elaine Georgia, calculate the average age.",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the `Staff` table (A) with the `Addresses` table (B) using `staff_address_id` to link coaches' data with their location information.  【step2】: Filter records where `B.state_province_county` is \"Georgia\" and `B.city` is \"Lake Elaina\" to isolate coaches in the specified region.  【step3】: Calculate the average age by evaluating `YEAR(CURDATE()) - YEAR(date_of_birth)`, adjusting for unpassed birthdays via `DATE_FORMAT`, then apply the `AVG()` function.",
        "type": 3,
        "idx": 2105
    },
    {
        "db_id": "school",
        "query": "SELECT 2 * AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Port Melyssa\"",
        "englishquestion": "If the average age of coaches living in Lake Elaine, Georgia is twice the average age of coaches living in Port Melyssa,Georgia, what is the average age of the coaches living in Lake Elaine, Georgia?",
        "reasoning_type": "- * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the Staff and Addresses tables based on staff_address_id and filter records to include only coaches in 'Port Melyssa, Georgia'.  【step2】: Calculate the exact age for each coach using date_of_birth and adjust for unpassed birthdays via DATE_FORMAT comparisons.  【step3】: Compute the average age of the filtered coaches and multiply by 2 to reflect the required ratio for Lake Elaine's average.",
        "type": 4,
        "idx": 2106
    },
    {
        "db_id": "school",
        "query": "SELECT 2 * AVG ( strftime ( \"%Y\" , \"now\" ) - strftime ( \"%Y\" , A.date_of_birth ) - ( strftime ( \"%m-%d\" , \"now\" ) < strftime ( \"%m-%d\" , A.date_of_birth ) ) ) AS avg_age FROM Staff A JOIN Addresses B ON A.staff_address_id = B.address_id WHERE B.state_province_county = \"Georgia\" AND B.city = \"Port Melyssa\"",
        "englishquestion": "What is the average age of coaches in Lake Elaine Georgia if the average ages of coaches here is twice the average of coaches living in Port Melyssa, Georgia?",
        "reasoning_type": "- * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the average age of coaches in Port Melyssa, Georgia with:  ```sql  SELECT AVG(YEAR(CURDATE()) - YEAR(date_of_birth) - (DATE_FORMAT(CURDATE(), '%m-%d') < DATE_FORMAT(date_of_birth, '%m-%d'))) AS port_avg  FROM Staff  WHERE staff_address_id IN (      SELECT address_id      FROM Addresses      WHERE city = 'Port Melyssa'      AND state_province_county = 'Georgia'  )  ```  【step2】: Multiply the result from step 1 by 2 to get Lake Elaine's average age.  【step3】: Use the final calculation as the answer (no additional SQL needed since it's a mathematical operation on the retrieved value).  *Note: The original query contained incorrect logic (directly multiplying by 2 in SQL) and city name inconsistencies (\"Port Melyssa\" vs \"Port Melyssa\"). This solution separates the critical components while maintaining accurate geographical references.*",
        "type": 4,
        "idx": 2107
    },
    {
        "db_id": "school",
        "query": "SELECT * FROM ( SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) AS diff FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" )",
        "englishquestion": "How old is Janessa Amara Sawayn five years after she left office, and how many years younger than Camylle Icie Weissnat?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate Janessa's age 5 years after leaving: Compute her age by (YEAR(date_left_staff) - YEAR(date_of_birth)) adjusted for month/day comparison, then add 5.  【step2】: Compute birthdate difference: Retrieve Camylle's date_of_birth, subtract Janessa's date_of_birth (via nested subquery) using DATEDIFF to get the day gap.  【step3】: Join both results: Combine the age calculation (t1) and birthdate difference (t2) into a single output via an implicit JOIN.",
        "type": 3,
        "idx": 2108
    },
    {
        "db_id": "school",
        "query": "SELECT * FROM ( SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) JOIN ( SELECT date_of_birth - ( SELECT date_of_birth FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\" ) AS diff FROM Staff WHERE first_name = \"Camylle\" AND middle_name = \"Icie\" AND last_name = \"Weissnat\" )",
        "englishquestion": "Give me Janessa Amara Sawayn's age five years after leaving office and how many years younger were they than Camylle Icie Weissnat?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate Janessa's age five years after leaving office by subtracting her birth year from her exit year, adjusting if her birthday hadn't occurred yet, and adding 5.  【step2】: Retrieve Camylle's birth date, compute the difference from Janessa's birth date via a nested subquery to determine the age gap.  【step3】: Combine both results using a JOIN to display the final age and age difference in a single output.",
        "type": 3,
        "idx": 2109
    },
    {
        "db_id": "school",
        "query": "SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age , 30 - ( strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\"",
        "englishquestion": "If Camylle Icie Weissnat is 30 years old when Janessa Amara Sawayn leaves, how old is Janessa Amara Sawayn five years after she left office, and how many years younger than Camylle Icie Weissnat?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Filter the Staff table to retrieve the specific record for Janessa Amara Sawayn using first_name, middle_name, and last_name in the WHERE clause.  【step2】: Calculate her age when leaving office: (YEAR(date_left_staff) - YEAR(date_of_birth)) with a conditional adjustment for birthdate precision using DATE_FORMAT comparisons on month-day.  【step3】: Compute final outputs: Add 5 years to her leaving-age for \"age\" and subtract her leaving-age from 30 to determine \"diff\" in age compared to Camylle.",
        "type": 4,
        "idx": 2110
    },
    {
        "db_id": "school",
        "query": "SELECT 5 + strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) AS age , 30 - ( strftime ( \"%Y\" , date_left_staff ) - strftime ( \"%Y\" , date_of_birth ) - ( strftime ( \"%m-%d\" , date_left_staff ) < strftime ( \"%m-%d\" , date_of_birth ) ) ) AS diff FROM Staff WHERE first_name = \"Janessa\" AND middle_name = \"Amara\" AND last_name = \"Sawayn\"",
        "englishquestion": "How old was Janessa Amara Sawayn five years after leaving office if Camylle Icie Weissnat was 30 years old when Janessa Amara Sawayn left? How much younger was Janessa Amara Sawayn than Camylle Icie Weissnat?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Filter the Staff table to retrieve the row for Janessa Amara Sawayn using first_name, middle_name, and last_name conditions.  【step2】: Calculate Janessa's age when leaving office: YEAR(date_left_staff) - YEAR(date_of_birth), adjusted by comparing month-day values to account for incomplete birth years.  【step3】: Compute two final results:  - Add 5 years to Janessa's leaving age (age at leaving + 5).  - Subtract Janessa's leaving age from Camylle's age (30) to determine the age difference (diff).",
        "type": 4,
        "idx": 2111
    },
    {
        "db_id": "hospital",
        "query": "SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "englishquestion": "How many days did John Smith stay in hospital?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Days in hospital is caculated by subtracting day of admission from day of discharge.",
        "english_step": "【step1】: Join Stay and Patient tables using Patient.SSN to link hospitalization records with patient information.  【step2】: Filter the combined data to retain only entries where Patient.name equals 'John Smith'.  【step3】: Calculate the date difference between StayEnd and StayStart using DATEDIFF(), then explicitly cast the result as a signed integer for clarity.",
        "type": 3,
        "idx": 2112
    },
    {
        "db_id": "hospital",
        "query": "SELECT CAST ( julianday ( A.StayEnd ) - julianday ( A.StayStart ) AS INTEGER ) AS days_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "englishquestion": "How long was John Smith admitted to the hospital?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Days in hospital is caculated by subtracting day of admission from day of discharge.",
        "english_step": "【step1】: Join the Stay (A) and Patient (B) tables using A.Patient = B.SSN to link hospitalization records with patient information.  【step2】: Apply WHERE B.name = 'John Smith' to filter records specifically for the patient named John Smith.  【step3】: Calculate the date difference between StayEnd and StayStart using DATEDIFF, then cast the result as SIGNED to return the hospitalization duration in days.",
        "type": 3,
        "idx": 2113
    },
    {
        "db_id": "hospital",
        "query": "SELECT julianday ( strftime ( \"%Y-\" , A.StayEnd ) || \"05-12\" ) - julianday ( strftime ( \"%Y-\" , A.StayStart ) || strftime ( \"%m-%d\" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "englishquestion": "If John Smith left the hospital on International Nurses Day, how many days did John Smith stay in the hospital?",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Days in hospital is caculated by subtracting day of admission from day of dischargel. International Nurses Day is an international day observed around the world on 12 May each year.",
        "english_step": "【step1】: Join the `Stay` table with the `Patient` table on `Patient.SSN = Stay.Patient` and filter for `Patient.name = 'John Smith'` to retrieve his hospitalization records.  【step2】: Replace the actual `StayEnd` date with a constructed International Nurses Day date (May 12 of the same year as `StayEnd`) using `STR_TO_DATE(CONCAT(YEAR(A.StayEnd), '-05-12'), '%Y-%m-%d')`.  【step3】: Calculate the day difference between the formatted `StayStart` and the constructed International Nurses Day using `DATEDIFF()`.",
        "type": 4,
        "idx": 2114
    },
    {
        "db_id": "hospital",
        "query": "SELECT julianday ( strftime ( \"%Y-\" , A.StayEnd ) || \"05-12\" ) - julianday ( strftime ( \"%Y-\" , A.StayStart ) || strftime ( \"%m-%d\" , A.StayStart ) ) AS date_diff FROM Stay A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"John Smith\"",
        "englishquestion": "If John Smith was discharged from the hospital on International Nurses Day, for how long was he admitted to the hospital?",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "Days in hospital is caculated by subtracting day of admission from day of dischargel. International Nurses Day is an international day observed around the world on 12 May each year.",
        "english_step": "【step1】: Join the \"Stay\" and \"Patient\" tables using SSN, filtering records where patient name is \"John Smith\".  【step2】: Extract year from StayEnd date, then reconstruct a new date using that year combined with fixed \"05-12\" (International Nurses Day).  【step3】: Calculate date difference between original admission date (StayStart) and the constructed discharge date using DATEDIFF().",
        "type": 4,
        "idx": 2115
    },
    {
        "db_id": "hospital",
        "query": "SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Foo Labs\"",
        "englishquestion": "How many more patients have used Foo Labs branded drugs than those have used Baz Industries branded drugs?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of distinct patients who used Foo Labs drugs by joining Medication and Prescribes tables, filtering with Brand='Foo Labs'.  【step2】: Calculate the number of distinct patients who used Baz Industries drugs via a subquery using the same table join method with Brand='Baz Industries'.  【step3】: Subtract the Baz Industries patient count (from step2) from the Foo Labs patient count (from step1) to get the final difference.",
        "type": 2,
        "idx": 2116
    },
    {
        "db_id": "hospital",
        "query": "SELECT COUNT ( DISTINCT ( Patient ) ) - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Foo Labs\"",
        "englishquestion": "What is the difference in the number of patients who have used drugs branded by Foo Labs compared to those who have used drugs branded by Baz Industries?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of distinct patients associated with \"Foo Labs\" by joining the Medication and Prescribes tables, filtering on `A.Brand = 'Foo Labs'`, and counting unique `Patient` values.  【step2】: Calculate the number of distinct patients associated with \"Baz Industries\" using a subquery with the same table join logic but filtering on `A.Brand = 'Baz Industries'`.  【step3】: Subtract the result of the subquery (Baz Industries patient count) from the main query's result (Foo Labs patient count) to compute the final `diff` value.",
        "type": 2,
        "idx": 2117
    },
    {
        "db_id": "hospital",
        "query": "SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff",
        "englishquestion": "If there were 10 patients who used Foo Labs brand drugs, how many more patients have used Foo Labs branded drugs than those have used Baz Industries branded drugs?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the Medication and Prescribes tables to link medications with prescriptions, filtering for records where the Brand is 'Baz Industries'.  【step2】: Calculate the count of distinct patients from the joined result to determine how many unique patients used Baz Industries drugs.  【step3】: Subtract the count from step 2 from the fixed value 10 to get the difference in patient counts between Foo Labs and Baz Industries.",
        "type": 4,
        "idx": 2118
    },
    {
        "db_id": "hospital",
        "query": "SELECT 10 - ( SELECT COUNT ( DISTINCT ( Patient ) ) FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Brand = \"Baz Industries\" ) AS diff",
        "englishquestion": "If 10 patients have used drugs branded by Foo Labs, how many additional patients have used Foo Labs branded drugs compared to the number of patients who have used drugs branded by Baz Industries?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the \"Medication\" and \"Prescribes\" tables where the medication codes match, filtering only records where the brand is 'Baz Industries'.  【step2】: Count the distinct number of patients from the joined result.  【step3】: Subtract this count from 10 to get the difference in patient numbers.",
        "type": 4,
        "idx": 2119
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "englishquestion": "How many times is the number of appointments made by the physician with the highest number of appointments compared to the physician with the lowest number of appointments?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Execute the inner subquery to group appointments by physician and count each group's entries, creating a temporary table \"sub\" with columns (Physician, c).  【step2】: Compute the maximum (MAX(c)) and minimum (MIN(c)) values from the \"c\" column in the \"sub\" table.  【step3】: Calculate the ratio of MAX(c) to MIN(c) and multiply by 1.0 to ensure a floating-point result, aliasing the final value as \"times\".",
        "type": 2,
        "idx": 2120
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( c ) / MIN ( c ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "englishquestion": "What is the ratio between the number of appointments made by the physician with the highest and lowest appointments?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Group appointments by physician and count the number of appointments for each one using `GROUP BY Physician` and `COUNT(*)`.  【step2】: Calculate the maximum and minimum appointment counts from the grouped results using `MAX(c)` and `MIN(c)`.  【step3】: Compute the ratio of the maximum to minimum counts with `1.0 * MAX(c) / MIN(c)` to ensure floating-point division.",
        "type": 2,
        "idx": 2121
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "englishquestion": "If the physician with the fewest appointments made 2 new appointments, how many times is the number of appointments made by the physician with the highest number of appointments compared to the physician with the lowest number of appointments?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of appointments for each physician by grouping the Appointment table and counting entries per Physician.  【step2】: Determine the maximum appointment count (highest) and the minimum appointment count (lowest) from the grouped results.  【step3】: Compute the ratio by dividing the highest count by (lowest count + 2) to account for the 2 new appointments, using 1.0* to ensure floating-point division.",
        "type": 4,
        "idx": 2122
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( c ) / ( MIN ( c ) + 2 ) AS times FROM ( SELECT Physician , COUNT ( * ) AS c FROM Appointment GROUP BY Physician )",
        "englishquestion": "If the physician who has the least number of appointments schedules 2 additional appointments, what is the ratio between the number of appointments made by the physician with the highest and him?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Subquery (t) groups appointments by physician and counts each group's total (c).  【step2】: Compute MAX(c) (highest appointment count) and MIN(c) (lowest appointment count) from subquery t.  【step3】: Calculate the ratio using 1.0*MAX(c)/(MIN(c)+2) to ensure floating-point division and handle the \"+2 appointments\" scenario.",
        "type": 4,
        "idx": 2123
    },
    {
        "db_id": "hospital",
        "query": "SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "englishquestion": "All drugs are 2 dollars per dose. How much did Dennis Doe spend on all drugs and treatment in total?",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity with unit price.",
        "english_step": "【step1】: Calculate medication cost by summing prescribed doses for 'Dennis Doe' and multiplying by $2 via subquery `med_sub`.  【step2】: Calculate procedure cost by summing all procedure costs linked to 'Dennis Doe' via subquery `pro_sub`.  【step3】: Combine results from both subqueries and output the total cost using `med_cost + pro_cost`.",
        "type": 3,
        "idx": 2124
    },
    {
        "db_id": "hospital",
        "query": "SELECT med_cost + pro_cost AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "englishquestion": "If all drugs cost 2 dollars per dose, what is the total amount spent by Dennis Doe on drugs and treatment?",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity with unit price.",
        "english_step": "【step1】: Calculate the total medication cost by multiplying the sum of prescribed doses by 2 for Dennis Doe from the **Prescribes** and **Patient** tables.  【step2】: Calculate the total procedure cost by summing the cost of all treatments linked to Dennis Doe from the **Procedures**, **Undergoes**, and **Patient** tables.  【step3】: Combine the results of step 1 and step 2 using a **CROSS JOIN** (since both subqueries return single values) and sum them as **total_cost**.",
        "type": 3,
        "idx": 2125
    },
    {
        "db_id": "hospital",
        "query": "SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" AND A.Date != \"2008-04-30 16:53\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "englishquestion": "All drugs are 2 dollars per dose. If Dennis Doe bought 10 more doses of Thesisin at 16:53 on April 30th, 2008, how much did Dennis Doe spend on all drugs and treatment in total?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity with unit price.",
        "english_step": "【step1】: Calculate the medication cost for Dennis Doe excluding the purchase on 2008-04-30 16:53 by summing doses from Prescribes, multiplying by 2 (since each dose costs $2).  【step2】: Calculate the total procedure cost for Dennis Doe by summing costs from Procedures linked via Undergoes.  【step3】: Combine the two calculated costs (med_cost and pro_cost) and add $20 (10 doses × $2) for the additional purchase to get the final total_cost.",
        "type": 4,
        "idx": 2126
    },
    {
        "db_id": "hospital",
        "query": "SELECT med_cost + pro_cost + 10 * 2 AS total_cost FROM ( SELECT 2 * SUM ( A.dose ) AS med_cost FROM Prescribes A JOIN Patient B ON A.Patient = B.SSN WHERE B.name = \"Dennis Doe\" AND A.Date != \"2008-04-30 16:53\" ) JOIN ( SELECT SUM ( COST ) AS pro_cost FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON B.Patient = C.SSN WHERE C.name = \"Dennis Doe\" )",
        "englishquestion": "If all drugs cost 2 dollars per dose and Dennis Doe purchased 10 additional doses of Thesisin at 16:53 on April 30, 2008, what is the total amount spent by Dennis Doe on all drugs and treatment?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity with unit price.",
        "english_step": "【step1】:Calculate the medication cost excluding the specified purchase: Sum all doses prescribed to Dennis Doe (excluding the April 30, 2008 16:53 record), multiply by $2 per dose using an INNER JOIN between Prescribes and Patient tables.  【step2】:Calculate the treatment procedure cost: Sum all procedure costs for Dennis Doe through an INNER JOIN chain across Procedures, Undergoes, and Patient tables.  【step3】:Combine results via CROSS JOIN: Add the medication cost (from step1), procedure cost (from step2), and the additional 10-dose purchase cost (10*2) to get the total amount.",
        "type": 4,
        "idx": 2127
    },
    {
        "db_id": "hospital",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "englishquestion": "How long is the validity period of John Wen''s trained procedures qualification certificate?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Lifetime of the certification is computed substacting certification start date from certification expire date.",
        "english_step": "【step1】: Join tables `Trained_In` (A), `Physician` (B), and `Procedures` (C) using `A.Physician = B.EmployeeID` and `C.code = A.Treatment` to link qualification, physician, and procedure data.  【step2】: Filter the joined data to retain only records where `B.name = 'John Wen'`.  【step3】: Calculate the validity period by applying `DATEDIFF(A.CertificationExpires, A.CertificationDate)` and alias it as `lifetime`, while explicitly casting the result as a signed integer.",
        "type": 3,
        "idx": 2128
    },
    {
        "db_id": "hospital",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "englishquestion": "What is the validity period of John Wen''s trained procedure qualification certificate?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "Lifetime of the certification is computed substacting certification start date from certification expire date.",
        "english_step": "【step1】: Join the `Trained_In` table with `Physician` using `EmployeeID` to filter records where `Physician.name` equals 'John Wen'.  【step2】: Join the result with `Procedures` using `code` to retrieve the associated procedure name.  【step3】: Calculate the validity period by subtracting `CertificationDate` from `CertificationExpires` with `DATEDIFF`, then cast the result as `SIGNED` for explicit integer output.",
        "type": 3,
        "idx": 2129
    },
    {
        "db_id": "hospital",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "englishquestion": "How long is the validity period of John Wen''s trained procedures qualification certificate, if the the validity period is extended by 180 days?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Lifetime of the certification is computed substacting certification start date from certification expire date.",
        "english_step": "【step1】: Join the \"Trained_In\", \"Physician\", and \"Procedures\" tables using their respective foreign keys (Physician.EmployeeID and Procedures.code).  【step2】: Calculate the original validity period with `DATEDIFF(A.CertificationExpires, A.CertificationDate)` and add 180 days to this value.  【step3】: Filter the results to only include records where the physician's name is \"John Wen\" and return the procedure name and extended validity period.",
        "type": 4,
        "idx": 2130
    },
    {
        "db_id": "hospital",
        "query": "SELECT C.name , CAST ( julianday ( A.CertificationExpires ) - julianday ( A.CertificationDate ) AS INTEGER ) + 180 AS lifetime FROM Trained_In A JOIN Physician B ON A.Physician = B.EmployeeID JOIN Procedures C ON C.code = A.Treatment WHERE B.name = \"John Wen\"",
        "englishquestion": "If the validity period of John Wen's trained procedures qualification certificate is extended by 180 days, what is the new validity period of the certificate?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Lifetime of the certification is computed substacting certification start date from certification expire date.",
        "english_step": "【step1】: Join the \"Trained_In\", \"Physician\", and \"Procedures\" tables to link the physician's qualifications with their identity and procedure details.  【step2】: Filter the joined data to retain only records where the physician's name is \"John Wen\".  【step3】: Calculate the extended validity period by adding 180 days to the original duration (difference between CertificationExpires and CertificationDate) using DATEDIFF and CAST.",
        "type": 4,
        "idx": 2131
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = \"Surgery\" or B.Name = \"General Medicine\" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "englishquestion": "What is the proportion of physicians who belong to both Surgery department and General Medicine department out of physicians who belong to Surgery department?",
        "reasoning_type": "/ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the DepartmentID for 'Surgery' from the Department table.  【step2】: Calculate the total number of physicians in the Surgery department using the DepartmentID obtained in Step1.  【step3】: Identify physicians affiliated with both 'Surgery' and 'General Medicine', count them as the numerator, and compute the proportion by dividing this count by the total from Step2.",
        "type": 2,
        "idx": 2132
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Affiliated_With WHERE Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID WHERE B.Name = \"Surgery\" or B.Name = \"General Medicine\" GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "englishquestion": "What is the ratio of physicians who are members of both the Surgery department and the General Medicine department, compared to the total number of physicians in the Surgery department?",
        "reasoning_type": "/ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the total number of physicians in the Surgery department by filtering the Affiliated_With table using the DepartmentID of 'Surgery' from the Department table.  【step2】: Identify physicians affiliated with both 'Surgery' and 'General Medicine' by joining Affiliated_With and Department, grouping by physicians, and filtering those with exactly two distinct department names.  【step3】: Calculate the ratio by dividing the count of dual-affiliated physicians (from step2) by the total Surgery department physicians (from step1), using 1.0 * to ensure floating-point division.",
        "type": 2,
        "idx": 2133
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != \"Keith Dudermeister\" and Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != \"Keith Dudermeister\" and ( B.Name = \"Surgery\" or B.Name = \"General Medicine\" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "englishquestion": "If Keith Dudermeister belongs to both the Surgery department and the General Medicine department, what is the proportion of physicians who belong to both the Surgery department and the General Medicine department among physicians who belong to the Surgery department?",
        "reasoning_type": "+ / * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the denominator: Count all physicians in the Surgery department (excluding Keith Dudermeister) and add 1 to avoid division errors. This is done via the subquery filtering `B.Name != 'Keith Dudermeister'` and matching the Surgery department.  【step2】: Calculate the numerator: Identify physicians (excluding Keith) affiliated with both Surgery and General Medicine via `GROUP BY Physician HAVING COUNT(DISTINCT B.Name) = 2`, then add 1 to include Keith as per the hypothetical condition.  【step3】: Compute the proportion by dividing the adjusted numerator by the adjusted denominator, using `1.0 *` to ensure floating-point division.",
        "type": 4,
        "idx": 2134
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * ( 1 + COUNT ( * ) ) / ( 1 + ( SELECT COUNT ( * ) FROM Affiliated_With as A join Physician as B on A.Physician = B.EmployeeID WHERE B.Name != \"Keith Dudermeister\" and Department = ( SELECT DepartmentID FROM Department WHERE Name = \"Surgery\" ) ) ) AS prop FROM ( select * from Affiliated_With as A join department as B on A.Department = B.DepartmentID join Physician as C on A.Physician = C.EmployeeID WHERE C.Name != \"Keith Dudermeister\" and ( B.Name = \"Surgery\" or B.Name = \"General Medicine\" ) GROUP BY Physician HAVING COUNT ( DISTINCT ( B.Name ) ) = 2 )",
        "englishquestion": "If Keith Dudermeister is a member of both the Surgery and General Medicine departments, what is the proportion of physicians who belong to both departments out of the total number of physicians in the Surgery department?",
        "reasoning_type": "+ / * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the count of physicians (excluding Keith) affiliated with both 'Surgery' and 'General Medicine' via subquery: Join **Affiliated_With**, **Department**, and **Physician**, filter by department names, group by physician, and keep those with exactly two distinct departments.  【step2】: Calculate total physicians in the Surgery department (excluding Keith) via nested subquery: Join **Affiliated_With** and **Physician**, filter by department ID derived from **Department**, and exclude Keith.  【step3】: Compute the proportion by combining results: Add 1 to both counts (to include Keith) in the numerator and denominator, then perform division with type conversion to ensure decimal output.",
        "type": 4,
        "idx": 2135
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures",
        "englishquestion": "How many times is the highest price of the treatments compared to the lowest price?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the maximum value of the Cost column from the Procedures table using MAX(Cost).  【step2】: Retrieve the minimum value of the Cost column from the same table using MIN(Cost).  【step3】: Calculate the ratio of these two values by dividing MAX(Cost) by MIN(Cost), and multiply by 1.0 to ensure floating-point division. Assign the result to the alias \"times\".",
        "type": 2,
        "idx": 2136
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( Cost ) / MIN ( Cost ) AS times FROM Procedures",
        "englishquestion": "What is the ratio between the highest and lowest prices of the treatments?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the maximum cost from the \"Cost\" column in the Procedures table using MAX(Cost).  【step2】: Retrieve the minimum cost from the \"Cost\" column in the Procedures table using MIN(Cost).  【step3】: Calculate the ratio by dividing the maximum cost by the minimum cost, multiplied by 1.0 to ensure floating-point division.",
        "type": 2,
        "idx": 2137
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures",
        "englishquestion": "How many times is the highest price of the treatments compared to the lowest price, if the the lowest price was increased by 75%?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Adjust the lowest price by increasing it by 75% using `(1 + 0.75) * MIN(Cost)`.  【step2】: Calculate the highest price using `MAX(Cost)`.  【step3】: Divide the highest price by the adjusted lowest price and ensure floating-point division with `1.0 * MAX(...) / adjusted_min`.",
        "type": 4,
        "idx": 2138
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * MAX ( Cost ) / ( ( 1 + 0.75 ) * MIN ( Cost ) ) AS times FROM Procedures",
        "englishquestion": "If the lowest price of the treatments was increased by 75%, what would be the new ratio between the highest and lowest prices?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the original MAX(Cost) and MIN(Cost) from the `Procedures` table.  【step2】: Calculate the adjusted lowest price by increasing the original MIN(Cost) by 75% (multiplying by 1.75).  【step3】: Compute the ratio between the original MAX(Cost) and the adjusted lowest price, ensuring floating-point division for precision.",
        "type": 4,
        "idx": 2139
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000",
        "englishquestion": "How many treatments with a cost higher than 1000 account for the total number of treatments?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of treatments where the cost exceeds 1000 using **COUNT(*)** filtered by **WHERE Cost > 1000**.  【step2】: Compute the total number of treatments in the **Procedures** table via a subquery **SELECT COUNT(*) FROM Procedures**.  【step3】: Divide the result of Step1 by Step2 and multiply by **1.0** to ensure floating-point division, producing the final ratio.",
        "type": 2,
        "idx": 2140
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Procedures ) FROM Procedures WHERE Cost > 1000",
        "englishquestion": "What proportion of treatments, out of the total number of treatments, cost higher than 1000?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of treatments using the subquery `(SELECT COUNT(*) FROM Procedures)`.  【step2】: Count the number of treatments where `Cost > 1000` via `COUNT(*) FROM Procedures WHERE Cost > 1000`.  【step3】: Divide the two results (cast as a float using `1.0 *`) to compute the proportion.",
        "type": 2,
        "idx": 2141
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = \"Procrastin-X\"",
        "englishquestion": "What is the proportion of patients who do not use Procrastin-X in the total number of patients?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of distinct patients using `COUNT(DISTINCT SSN)` on the **Patient** table.  【step2】: Count distinct patients prescribed \"Procrastin-X\" by joining **Medication** and **Prescribes** on `code = Medication` and filtering with `Name = 'Procrastin-X'`.  【step3】: Compute the proportion by subtracting the ratio of patients using Procrastin-X (Step2) to total patients (Step1) from 1.0.",
        "type": 2,
        "idx": 2142
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 - 1.0 * COUNT ( DISTINCT ( Patient ) ) / ( SELECT COUNT ( DISTINCT ( SSN ) ) FROM Patient ) AS prop FROM Medication A JOIN Prescribes B ON A.code = B.Medication WHERE A.Name = \"Procrastin-X\"",
        "englishquestion": "What proportion of patients, out of the total number of patients, do not use Procrastin-X?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of distinct patients using the subquery `(SELECT COUNT(DISTINCT SSN) FROM Patient)`, where SSN serves as the unique patient identifier.  【step2】: Identify patients prescribed \"Procrastin-X\" by joining the **Medication** and **Prescribes** tables on `code = Medication`, filtering with `A.Name = 'Procrastin-X'`, and counting distinct `Patient` values.  【step3】: Compute the proportion by subtracting the ratio of \"Procrastin-X\" patients (from Step 2) to the total patients (from Step 1) from `1.0`, ensuring floating-point division via `1.0 *` multipliers.",
        "type": 2,
        "idx": 2143
    },
    {
        "db_id": "hospital",
        "query": "SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "englishquestion": "How much is the difference between Dennis Doe's most expensive treatment and his cheapest treatment?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the \"Procedures\", \"Undergoes\", and \"Patient\" tables to link treatment costs with Dennis Doe's records.  【step2】: Filter the joined dataset to only include entries where the patient's name is 'Dennis Doe'.  【step3】: Calculate the difference between the maximum and minimum treatment costs from the filtered results using `MAX(A.Cost) - MIN(A.Cost)`.",
        "type": 2,
        "idx": 2144
    },
    {
        "db_id": "hospital",
        "query": "SELECT MAX ( A.Cost ) - MIN ( A.Cost ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "englishquestion": "What is the difference between Dennis Doe's most expensive and least expensive treatments?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the \"Procedures\", \"Undergoes\", and \"Patient\" tables using their respective keys to link treatment records with Dennis Doe. Filter to retain only records where the patient's name is 'Dennis Doe'.  【step2】: Extract the cost values of all treatments associated with Dennis Doe from the joined dataset.  【step3】: Calculate the difference between the maximum and minimum treatment costs using the MAX() and MIN() aggregate functions on the extracted cost values.",
        "type": 2,
        "idx": 2145
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "englishquestion": "If the price of each treatment was increased by 50%, how much is the difference between Dennis Doe's most expensive treatment and his cheapest treatment?",
        "reasoning_type": "- + * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the Patient, Undergoes, and Procedures tables to retrieve all treatment records associated with Dennis Doe.  【step2】: Calculate the original maximum and minimum treatment costs from the filtered records.  【step3】: Apply the 50% price increase to both values and compute their difference using **(1.5 * MAX(Cost)) - (1.5 * MIN(Cost))**.",
        "type": 4,
        "idx": 2146
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( ( 1 + 0.5 ) * MAX ( A.Cost ) ) - ( ( 1 + 0.5 ) * MIN ( A.Cost ) ) AS diff FROM Procedures A JOIN Undergoes B ON A.Code = B.Procedures JOIN Patient C ON C.SSN = B.Patient WHERE C.Name = \"Dennis Doe\"",
        "englishquestion": "If the price of each treatment was increased by 50%, what would be the difference between Dennis Doe's most expensive and least expensive treatments?",
        "reasoning_type": "- + * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the `Procedures`, `Undergoes`, and `Patient` tables using their respective keys to filter records associated with 'Dennis Doe'.  【step2】: Calculate the original maximum and minimum treatment costs (`MAX(A.Cost)` and `MIN(A.Cost)`) from the filtered results.  【step3】: Apply a 50% increase to both values and compute their difference using `(1.5 * MAX) - (1.5 * MIN)` to get the final `diff`.",
        "type": 4,
        "idx": 2147
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = \"0\"",
        "englishquestion": "How many available rooms account for the total number of rooms?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of rooms using the subquery `(SELECT COUNT(*) FROM Room)`.  【step2】: Determine the count of available rooms by filtering `WHERE Unavailable = 0`.  【step3】: Compute the proportion by dividing the available count by the total count, using `1.0 *` to ensure floating-point division.",
        "type": 2,
        "idx": 2148
    },
    {
        "db_id": "hospital",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Room ) AS prop FROM Room WHERE Unavailable = \"0\"",
        "englishquestion": "What is the proportion of available rooms to the total number of rooms?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of rooms using a subquery: `(SELECT COUNT(*) FROM Room)`.  【step2】: Count available rooms by filtering with `WHERE Unavailable = '0'`: `COUNT(*) FROM Room WHERE Unavailable = '0'`.  【step3】: Compute the proportion by dividing the available count by the total count, ensuring floating-point division with `1.0 *`: `1.0 * (step2 result) / (step1 result) AS prop`.",
        "type": 2,
        "idx": 2149
    },
    {
        "db_id": "hospital",
        "query": "SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = \"0\"",
        "englishquestion": "If there are two beds in each room, how many people can be accommodated in the available room in total?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter the \"Room\" table to only include available rooms where Unavailable is '0'.  【step2】: Count the number of available rooms using `COUNT(*)`.  【step3】: Multiply the count by 2 (since each room accommodates 2 people) and alias the result as `n_people`.",
        "type": 2,
        "idx": 2150
    },
    {
        "db_id": "hospital",
        "query": "SELECT 2 * COUNT ( * ) AS n_people FROM Room WHERE Unavailable = \"0\"",
        "englishquestion": "If each room has two beds, what is the total number of people that can be accommodated in all the available rooms?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter available rooms by selecting rows where Unavailable is '0'  【step2】: Count the number of available rooms using COUNT(*)  【step3】: Multiply the room count by 2 (beds per room) and alias the result as n_people",
        "type": 2,
        "idx": 2151
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "englishquestion": "What is the duration in minutes of an appointment with an appointment ID of 13216584?",
        "reasoning_type": "- / C",
        "commonsense_knowledge": "One hour is 60 minutes.",
        "english_step": "【step1】: Filter the Appointment table where AppointmentID is '13216584' to find the specific appointment.  【step2】: Calculate the time difference between End and Start times in seconds using UNIX_TIMESTAMP.  【step3】: Convert the time difference from seconds to minutes by dividing by 60.0 and return as 'time'.",
        "type": 3,
        "idx": 2152
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "englishquestion": "How long is the appointment with appointment ID 13216584 in minutes?",
        "reasoning_type": "- / C",
        "commonsense_knowledge": "One hour is 60 minutes.",
        "english_step": "【step1】: Filter the Appointment table to retrieve the record with AppointmentID '13216584'.  【step2】: Calculate the time difference between End and Start in seconds using UNIX_TIMESTAMP().  【step3】: Convert the seconds to minutes by dividing by 60 and alias the result as 'time'.",
        "type": 3,
        "idx": 2153
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "englishquestion": "If the duration of the appointment with an appointment ID 13216584 is extended for half an hour, how many minutes will it last?",
        "reasoning_type": "- + / C H",
        "commonsense_knowledge": "Half an hour is 30 minutes.",
        "english_step": "【step1】: Retrieve the Start and End timestamps for the appointment with ID '13216584' from the Appointment table.  【step2】: Calculate the original duration in minutes using `(UNIX_TIMESTAMP(End) - UNIX_TIMESTAMP(Start)) / 60.0` to convert the timestamp difference to minutes.  【step3】: Add 30 minutes to the original duration to reflect the extension and return the total duration as `time`.",
        "type": 4,
        "idx": 2154
    },
    {
        "db_id": "hospital",
        "query": "SELECT ( strftime ( \"%s\" , End ) - strftime ( \"%s\" , Start ) ) / 60.0 + 30 AS time FROM Appointment WHERE AppointmentID = \"13216584\"",
        "englishquestion": "If the appointment with appointment ID 13216584 is extended by 30 minutes, what will be the new total duration of the appointment in minutes?",
        "reasoning_type": "- + / C H",
        "commonsense_knowledge": "Half an hour is 30 minutes.",
        "english_step": "【step1】: Retrieve the start and end times of the appointment with ID '13216584' from the Appointment table using the WHERE clause.  【step2】: Calculate the original duration in minutes by subtracting the UNIX timestamps of Start and End, then dividing by 60.0 to convert seconds to minutes.  【step3】: Add 30 minutes to the original duration to get the new total duration, aliased as \"time\".",
        "type": 4,
        "idx": 2155
    },
    {
        "db_id": "hospital",
        "query": "SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )",
        "englishquestion": "If the training fee for each training is 50, who is the physician who spent the most on training? List his name, position, and training expenses.",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Join the Physician and Trained_In tables to associate each physician with their training records. Calculate the training cost (50 * training count) and group by physician.  【step2】: In a subquery, compute the maximum training count across all physicians by grouping and aggregating the Trained_In table.  【step3】: Filter the grouped results from step1 using HAVING to match the maximum training count from step2, ensuring only the physician(s) with the highest expense are selected.",
        "type": 2,
        "idx": 2156
    },
    {
        "db_id": "hospital",
        "query": "SELECT A.Name , A.Position , 50 * COUNT ( * ) AS cost FROM Physician A JOIN Trained_In B ON A.EmployeeID = B.Physician GROUP BY A.EmployeeID HAVING COUNT ( * ) = ( SELECT MAX ( training_count ) FROM ( SELECT COUNT ( * ) AS training_count FROM Trained_In GROUP BY Physician ) )",
        "englishquestion": "Which physician has incurred the highest training expenses, if the training fee for each session is 50? Provide their name, position, and total training expense.",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total training sessions per physician by joining the Physician and Trained_In tables, grouping by physician, and multiplying the session count by 50 to compute the cost.  【step2】: Determine the maximum number of training sessions across all physicians using a subquery that aggregates and calculates the max count from the Trained_In table.  【step3】: Filter the grouped results to retain only the physician(s) whose training session count matches the maximum value found in step 2, returning their name, position, and total expense.",
        "type": 2,
        "idx": 2157
    },
    {
        "db_id": "hospital",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )",
        "englishquestion": "How many more rooms are available on the top floor than on the bottom floor?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Determine the highest (MAX) and lowest (MIN) BlockFloor values from the Room table using subqueries.  【step2】: Calculate the number of available rooms (Unavailable = '0') on the top floor (MAX BlockFloor) with the outer query's main COUNT(*).  【step3】: Subtract the available rooms on the bottom floor (MIN BlockFloor), computed via a nested subquery, from the top floor count to get the difference (diff).",
        "type": 2,
        "idx": 2158
    },
    {
        "db_id": "hospital",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MAX ( BlockFloor ) FROM Room )",
        "englishquestion": "What is the difference in the number of available rooms on the top and bottom floors?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the maximum floor number using a subquery: (SELECT MAX(BlockFloor) FROM Room).  【step2】: Calculate available rooms on max floor (WHERE Unavailable=0) and min floor via nested subquery: (SELECT MIN(BlockFloor)...).  【step3】: Subtract the bottom floor count from the top floor count using arithmetic operation COUNT(*) - (subquery result).",
        "type": 2,
        "idx": 2159
    },
    {
        "db_id": "hospital",
        "query": "SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff",
        "englishquestion": "Suppose there are 20 available rooms on the top floor, how many more rooms are available on the top floor than on the bottom floor?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the lowest floor number by executing the innermost subquery: `SELECT MIN(BlockFloor) FROM Room`.  【step2】: Calculate the number of available rooms on the lowest floor using the result from step 1: `SELECT COUNT(*) FROM Room WHERE Unavailable = '0' AND BlockFloor = [lowest_floor]`.  【step3】: Subtract the count from step 2 from the fixed value 20 (top-floor available rooms) to get the difference: `SELECT 20 - [step2_count] AS diff`.",
        "type": 4,
        "idx": 2160
    },
    {
        "db_id": "hospital",
        "query": "SELECT 20 - ( SELECT COUNT ( * ) FROM Room WHERE Unavailable = \"0\" AND BlockFloor = ( SELECT MIN ( BlockFloor ) FROM Room ) ) AS diff",
        "englishquestion": "If the top floor has 20 available rooms, what is the difference in the number of available rooms between the top and bottom floors?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Find the minimum BlockFloor value in the Room table using `(SELECT MIN(BlockFloor) FROM Room)`.  【step2】: Count available rooms (where Unavailable = '0') on the identified minimum floor with `(SELECT COUNT(*) FROM Room WHERE Unavailable = '0' AND BlockFloor = [step1_result])`.  【step3】: Subtract the count from step2 from the fixed value 20 to calculate the difference, aliased as `diff`.",
        "type": 4,
        "idx": 2161
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach",
        "englishquestion": "What is the percentage of players with coaches in the total number of players?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Execute the subquery to calculate the total number of distinct players: `SELECT COUNT(DISTINCT Player_ID) FROM player`.  【step2】: Calculate the number of distinct players with coaches from the `player_coach` table: `COUNT(DISTINCT Player_ID)`.  【step3】: Compute the percentage by dividing the result from Step 2 by Step 1 and multiplying by 100.0, then alias the output as `ratio`.",
        "type": 2,
        "idx": 2162
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( DISTINCT ( Player_ID ) ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach",
        "englishquestion": "What percentage of total players have coaches?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of distinct players with coaches by using COUNT(DISTINCT Player_ID) on the player_coach table.  【step2】: Retrieve the overall distinct player count via a subquery (SELECT COUNT(DISTINCT Player_ID) FROM player).  【step3】: Compute the percentage by dividing the two values, multiplying by 100.0 for decimal precision, and aliasing the result as \"ratio\".",
        "type": 2,
        "idx": 2163
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != \"Jim Maloway\"",
        "englishquestion": "If Jim Maloway's coach is Joe Fabbri, what is the percentage of players with coaches in the total number of players?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of distinct players using the subquery: `SELECT COUNT(DISTINCT Player_ID) FROM player`.  【step2】: Compute the count of players with coaches by joining `player_coach` and `player`, excluding \"Jim Maloway\" via `WHERE B.Player_name != 'Jim Maloway'`, then add 1 (to include Jim Maloway's hypothetical coach) via `COUNT(DISTINCT A.Player_ID) + 1`.  【step3】: Combine the results to calculate the percentage: multiply the adjusted coached player count by 100.0 and divide by the total player count from step 1.",
        "type": 4,
        "idx": 2164
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( DISTINCT ( A.Player_ID ) ) + 1 ) / ( SELECT COUNT ( DISTINCT ( Player_ID ) ) FROM player ) AS ratio FROM player_coach A JOIN player B ON A.Player_ID = B.Player_ID WHERE B.Player_name != \"Jim Maloway\"",
        "englishquestion": "What percentage of players have a coach under the premise of Joe Fabbri coaching Jim Maloway?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of distinct players using a subquery:  `(SELECT COUNT(DISTINCT Player_ID) FROM player)`  【step2】: Join the `player_coach` and `player` tables to find players with coaches. Exclude \"Jim Maloway\" via `WHERE B.Player_name != 'Jim Maloway'`, counting distinct `Player_ID` from `player_coach` (denoted as `COUNT(DISTINCT A.Player_ID)`).  【step3】: Add 1 to the counted players (compensating for the excluded \"Jim Maloway\" who is coached by Joe Fabbri) and calculate the percentage by dividing the adjusted count by the total players from step1, then multiplying by 100.0.",
        "type": 4,
        "idx": 2165
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\"",
        "englishquestion": "What percentage of the total number of clubs were built before the year the Bitcoin Network was first launched?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Bitcoin Network was first launched in January 2009.",
        "english_step": "【step1】: Calculate the total number of clubs using the subquery `(SELECT COUNT(*) FROM club)`.  【step2】: Count clubs built before 2009 with `COUNT(*)` filtered by `WHERE Start_year < '2009'`.  【step3】: Compute the percentage by dividing the two counts and multiplying by 100.0 to ensure floating-point division.",
        "type": 3,
        "idx": 2166
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\"",
        "englishquestion": "How many clubs, out of the total number, were constructed and opened prior to the launching of the Bitcoin Network?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Bitcoin Network was first launched in January 2009.",
        "english_step": "【step1】: Filter clubs with Start_year earlier than 2009 and count them using `COUNT(*)`.  【step2】: Calculate the total number of clubs via the subquery `(SELECT COUNT(*) FROM club)`.  【step3】: Compute the ratio by dividing the count from Step1 by the result of Step2, then multiply by 100.0 to get the percentage.",
        "type": 3,
        "idx": 2167
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\" AND Club_name != \"Helsingborgs IF\"",
        "englishquestion": "If the Helsingborgs IF Club was established in 2000 instead, what percentage of the total number of clubs were built before the year the Bitcoin Network was first launched?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "Bitcoin Network was first launched in January 2009.",
        "english_step": "【step1】: Calculate the number of clubs established before 2009 (Bitcoin Network's launch year) excluding the original 'Helsingborgs IF', then add 1 to account for the hypothetical 2000 establishment.  【step2】: Retrieve the total number of clubs in the database.  【step3】: Compute the percentage by dividing the adjusted count (Step1) by the total clubs (Step2), then multiply by 100.0 for final ratio.",
        "type": 4,
        "idx": 2168
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( * ) + 1 ) / ( SELECT COUNT ( * ) FROM club ) AS ratio FROM club WHERE Start_year < \"2009\" AND Club_name != \"Helsingborgs IF\"",
        "englishquestion": "Which clubs, as a percentage of total clubs, existed prior to the foundation of the Bitcoin Network if the Helsingborgs IF Club was actuallly established in 2000?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "Bitcoin Network was first launched in January 2009.",
        "english_step": "【step1】: Filter clubs established before 2009 (Bitcoin Network's foundation year) while excluding \"Helsingborgs IF\" using `WHERE Start_year < '2009' AND Club_name != 'Helsingborgs IF'`, and count them.  【step2】: Calculate the total number of clubs using a subquery `(SELECT COUNT(*) FROM club)`.  【step3】: Adjust the count by adding 1 (to include the corrected establishment year of Helsingborgs IF), compute the percentage with `100.0 * (COUNT(*) + 1) / total_clubs`, and return the final ratio.",
        "type": 4,
        "idx": 2169
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "englishquestion": "How many medals have all the clubs in the country that owns the world's longest railway won?",
        "reasoning_type": "+ C",
        "commonsense_knowledge": "The Trans-Siberian Railway located at Russia is the longest railway line in the world.",
        "english_step": "【step1】: Filter clubs located in the country owning the world's longest railway (Russia) via WHERE A.Region = 'Russia'  【step2】: Join club and match_result tables using Club_ID to access medal records  【step3】: Calculate total medals by summing Gold, Big_Silver, Small_Silver and Bronze columns across all matching rows",
        "type": 3,
        "idx": 2170
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT SUM ( Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "englishquestion": "What is the medal count for all clubs located in the same country as the longest railway in the world?",
        "reasoning_type": "+ C",
        "commonsense_knowledge": "The Trans-Siberian Railway located at Russia is the longest railway line in the world.",
        "english_step": "【step1】: Retrieve all clubs located in Russia by filtering the `club` table where `Region` equals 'Russia'.  【step2】: Join the filtered clubs with the `match_result` table using `Club_ID` to access medal data.  【step3】: Calculate the total medal count by summing `Gold`, `Big_Silver`, `Small_Silver`, and `Bronze` values for the joined results.",
        "type": 3,
        "idx": 2171
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "englishquestion": "How many medals have all the clubs in the country that owns the world's longest railway won if the number of gold medal of each club was doubled?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "The Trans-Siberian Railway located at Russia is the longest railway line in the world.",
        "english_step": "【step1】: Join the `club` and `match_result` tables using `Club_ID`, then filter clubs located in Russia (country with the world's longest railway) via `WHERE A.Region = 'Russia'`.  【step2】: For each qualifying club, calculate adjusted medals by doubling `Gold` (via `2 * Gold`) and summing it with other medal types (`Big_Silver`, `Small_Silver`, `Bronze`).  【step3】: Aggregate the adjusted medal counts across all qualifying clubs using `SUM()` to produce the final `total_medals` result.",
        "type": 4,
        "idx": 2172
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT SUM ( 2 * Gold + Big_Silver + Small_Silver + Bronze ) AS total_medals FROM club A JOIN match_result B ON A.Club_ID = B.Club_ID WHERE A.Region = \"Russia\"",
        "englishquestion": "Assuming the number of gold medal of each club was doubled, what is the medal count for all clubs located in the same country as the longest railway in the world?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "The Trans-Siberian Railway located at Russia is the longest railway line in the world.",
        "english_step": "【step1】: Identify the country with the longest railway in the world (implied as \"Russia\" from the WHERE clause).  【step2】: Join the \"club\" and \"match_result\" tables to link clubs with their medal data, filtering clubs located in Russia.  【step3】: Calculate the adjusted medal count by doubling the Gold medals, summing all medals (2*Gold + Big_Silver + Small_Silver + Bronze), and return the total for eligible clubs.",
        "type": 4,
        "idx": 2173
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "englishquestion": "How many times more medals does the top ranked club have than the third ranked club?",
        "reasoning_type": "+ * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of medals (Gold + Big_Silver + Small_Silver + Bronze) for the club ranked 1st in the match_result table.  【step2】: Calculate the total number of medals for the club ranked 3rd using the same medal summation logic.  【step3】: Join the two results and compute the ratio (1st-ranked medals / 3rd-ranked medals) as times, using 1.0* to ensure floating-point division.",
        "type": 2,
        "idx": 2174
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "englishquestion": "What is the ratio of medals between the top ranked and third ranked club?",
        "reasoning_type": "+ * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve total medals for the top-ranked club (rank=1) by summing all medal columns (Gold, Big_Silver, Small_Silver, Bronze) into \"n_1\".  【step2】: Retrieve total medals for the third-ranked club (rank=3) using the same summation method, storing it as \"n_3\".  【step3】: Calculate the ratio via cross-joining the two results and computing 1.0*n_1/n_3 to preserve decimal precision.",
        "type": 2,
        "idx": 2175
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "englishquestion": "How many times more medals does the top ranked club have than the third ranked club, if the number of bronze medals of the top ranked club was tripled?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the adjusted total medals for the top-ranked club (rank=1) by tripling its bronze medals: `Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1` from the `match_result` table.  【step2】: Calculate the total medals for the third-ranked club (rank=3) without adjustments: `Gold + Big_Silver + Small_Silver + Bronze AS n_3` from the `match_result` table.  【step3】: Compute the ratio between the top-ranked club's adjusted medals (n_1) and the third-ranked club's total medals (n_3) using `1.0 * n_1 / n_3 AS times` by joining the two subqueries.",
        "type": 4,
        "idx": 2176
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * n_1 / n_3 AS times FROM ( SELECT Gold + Big_Silver + Small_Silver + 3 * Bronze AS n_1 FROM match_result WHERE rank = \"1\" ) JOIN ( SELECT Gold + Big_Silver + Small_Silver + Bronze AS n_3 FROM match_result WHERE rank = \"3\" )",
        "englishquestion": "If the number of bronze medals for the highest-ranking club was tripled, how many times more medals does the highest-ranking club club have compared to the thrid ranked club?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the adjusted medal count for the highest-ranking club (rank=1) by tripling its bronze medals and summing with other medals.  【step2】: Calculate the total medal count for the third-ranked club (rank=3) by summing all medals without adjustment.  【step3】: Join the two results and compute the ratio of the highest-ranking club's adjusted medals to the third-ranked club's medals.",
        "type": 4,
        "idx": 2177
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"F\" )",
        "englishquestion": "If a gold medal equals 5 points, a big silver medal equals 3 points, a small silver equals 2 points, and a bronze equals 1 point, where is the club with the highest number of points located, when was it established, and how many male and female coaches does it have?",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the highest scoring club using medal points (5*Gold +3*Big_Silver +2*Small_Silver +1*Bronze) via subquery, find its Club_ID.  【step2】: Count male coaches (Gender='M') for this club with GROUP BY Region/Start_year in one subquery, and count female coaches (Gender='F') in a separate subquery.  【step3】: Combine male coach count (containing Region/Start_year) and female coach count via CROSS JOIN to produce final unified output.",
        "type": 2,
        "idx": 2178
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze ) AS new_points , Club_ID FROM match_result ) ) AND B.Gender = \"F\" )",
        "englishquestion": "Assuming you converted a gold medal to 5 points, a big silver medal to 3 points, a small silver to two points and a bronze medal to 1 point, where is the highest scoring club located, when was it established, and what are the male coach count and the female coach count for the club?",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total points for each club in the match_result table using the medal-to-point conversion formula (5*Gold + 3*Big_Silver + 2*Small_Silver + 1*Bronze), then identify the Club_ID with the maximum points via a nested subquery (sub1/sub2).  【step2】: Retrieve the club's Region and Start_year from the club table, while also counting male coaches (n_M) by joining with the coach table and filtering Gender = 'M' for the identified Club_ID (t1 subquery).  【step3】: In parallel, count female coaches (n_F) using the same Club_ID via a similar join and filter (Gender = 'F') in the t2 subquery, then combine both counts with the club details using a final JOIN.",
        "type": 2,
        "idx": 2179
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"F\" )",
        "englishquestion": "If a gold medal equals 5 points, a big silver medal equals 3 points, a small silver equals 2 points, a bronze equals 1 point and the number of bronze medals of clubs that have the most and fewest number of gold medals were the same, where is the club with the highest number of points located, when was it established, and how many male and female coaches does it have?",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the adjusted points for clubs by handling two scenarios: clubs with the most gold medals use their original bronze count, while clubs with the fewest gold medals take the bronze count from the club with the most gold medals. Combine these results using UNION.  【step2】: Identify the club with the highest total points from the UNION result, and extract its Club_ID.  【step3】: Retrieve the club's region, founding year, and count male/female coaches by joining the club and coach tables using the identified Club_ID.",
        "type": 4,
        "idx": 2180
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT * FROM ( SELECT A.Region , A.Start_year , COUNT ( * ) AS n_M FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"M\" ) JOIN ( SELECT COUNT ( * ) AS n_F FROM club A JOIN coach B ON A.Club_ID = B.Club_ID WHERE A.Club_ID = ( SELECT Club_ID FROM ( SELECT MAX ( new_points ) , Club_ID FROM ( SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * Bronze AS new_points , Club_ID FROM match_result WHERE Club_ID != ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) UNION SELECT 5 * Gold + 3 * Big_Silver + 2 * Small_Silver + 1 * ( SELECT Bronze FROM ( SELECT MAX ( Gold ) , Bronze FROM match_result ) ) AS new_points , Club_ID FROM match_result WHERE Club_ID = ( SELECT Club_ID FROM ( SELECT MIN ( Gold ) , Club_ID FROM match_result ) ) ) ) ) AND B.Gender = \"F\" )",
        "englishquestion": "If the clubs with the highest and lowest number of gold medals had an equivalent number of bronze medals --- find me where the highest scoring club is located, when it was established, and the male coach count and the female coach count for the club if you converted all medals to points when a gold medal is 5 points, a big silver medal is 3 points, a small silver medal is 2 points and a bronze medal is 1 point.",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: **Identify the club with the highest gold medals** and the club with the lowest gold medals. Check if they have the same bronze count. Use subqueries to calculate their bronze equivalence by dynamically substituting the bronze count of the highest-gold club into the lowest-gold club's calculation.  【step2】: **Calculate weighted scores** for all clubs using the formula `5*Gold + 3*Big_Silver + 2*Small_Silver + 1*Bronze` (with bronze replaced for the lowest-gold club). Filter out non-matching clubs, sort by the score, and isolate the top-scoring club's ID.  【step3】: **Join the identified club** with `club` and `coach` tables to extract its region, establishment year, and count male/female coaches via partitioned `COUNT` with gender filters. Merge results into a final output with columns `Region`, `Start_year`, `n_M`, and `n_F`.",
        "type": 4,
        "idx": 2181
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" GROUP BY Player_ID )",
        "englishquestion": "What is the proportion of small businessman among the contestants who have won the championship?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of unique champions by selecting Player_IDs with Rank='1st' and grouping to avoid duplicates.  【step2】: Calculate the number of unique champions with Occupation='Small Businessman' using the same deduplication method.  【step3】: Compute the proportion by dividing the result from Step2 by Step1, using 1.0* to ensure floating-point division.",
        "type": 2,
        "idx": 2182
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" GROUP BY Player_ID ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" GROUP BY Player_ID )",
        "englishquestion": "Out of contestants winning the championship, how many of them are small businessman as a proportion?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of unique championship-winning players by selecting `Player_ID` from the `player` table where `Rank` is '1st' and grouping to eliminate duplicates.  【step2】: Calculate the subset of championship-winning players who are 'Small Businessman' by filtering with `Occupation = 'Small Businessman'` in addition to `Rank = '1st'`, also grouping by `Player_ID` to ensure uniqueness.  【step3】: Divide the count of small businessman winners by the total championship winners (from step1) and multiply by `1.0` to force floating-point division, producing the final proportion.",
        "type": 2,
        "idx": 2183
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" AND Occupation = \"Small Businessman\" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" and Player_name != \"Ross Eadie\" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" AND Player_name != \"Ross Eadie\" GROUP BY Player_ID )",
        "englishquestion": "If Ross Eadie won the first place instead, what is the proportion of small businessman among the contestants who have won the championship?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the base count of unique champion Small Businessman (excluding Ross Eadie) using SELECT DISTINCT Player_ID FROM player WHERE Rank='1st' AND Occupation='Small Businessman' AND Player_name != 'Ross Eadie'.  【step2】: Compute two conditional counts:  - Potential Ross Eadie's Small Businessman status: (SELECT COUNT(*) FROM player WHERE Player_name='Ross Eadie' AND Occupation='Small Businessman')  - Original champion count without Ross: (SELECT COUNT(*) FROM (SELECT DISTINCT Player_ID FROM player WHERE Rank='1st' AND Player_name != 'Ross Eadie') AS sub1)  【step3】: Combine values using formula (base_small_biz + potential_ross_biz) / (original_champ_count + ross_as_champ_count) where ross_as_champ_count is (SELECT COUNT(*) FROM player WHERE Player_name='Ross Eadie'), then output as proportion.",
        "type": 4,
        "idx": 2184
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" AND Occupation = \"Small Businessman\" ) ) / ( ( SELECT COUNT ( * ) FROM ( SELECT * FROM player WHERE Rank = \"1st\" and Player_name != \"Ross Eadie\" GROUP BY Player_ID ) ) + ( SELECT COUNT ( * ) FROM player WHERE Player_name = \"Ross Eadie\" ) ) AS propotion FROM ( SELECT * FROM player WHERE Rank = \"1st\" AND Occupation = \"Small Businessman\" AND Player_name != \"Ross Eadie\" GROUP BY Player_ID )",
        "englishquestion": "What proportion of the winning contestants are small businessmen if Ross Eadie won first place instead of their actual placement?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of unique 1st-place contestants who are small businessmen (excluding Ross Eadie) using the main subquery with GROUP BY Player_ID.  【step2】: Compute the numerator by adding Ross Eadie's eligibility (1 if he's a Small Businessman, else 0) to the count from Step 1.  【step3】: Calculate the denominator as the sum of unique original 1st-place contestants (excluding Ross Eadie) and Ross Eadie's total entries, then divide the numerator by this denominator to get the proportion.",
        "type": 4,
        "idx": 2185
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\"",
        "englishquestion": "What is the probability of a contestant guided by Jameson Tomas winning the championship?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the total number of contestants coached by Jameson Tomas using a subquery by joining the player, player_coach, and coach tables with the condition Coach_name = 'Jameson Tomas'.  【step2】: Count the number of contestants coached by Jameson Tomas who won the championship (Rank = '1st') by joining the same tables and applying both Coach_name and Rank filters.  【step3】: Divide the championship-winning count (Step2) by the total coached contestants (Step1) using 1.0 * to ensure floating-point division, returning the probability.",
        "type": 3,
        "idx": 2186
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\"",
        "englishquestion": "If a contestant is guided by Jameson Tomas then what probability is there of this contestant winning the championship?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the total number of contestants guided by Jameson Tomas using a subquery. This is done by joining the `player`, `player_coach`, and `coach` tables, filtering where `Coach_name = 'Jameson Tomas'`.  【step2】: Count how many of these contestants have a `Rank` of '1st' (indicating championship winners) by repeating the same joins and adding the condition `A.Rank = '1st'` in the main query.  【step3】: Divide the number of championship winners (from step 2) by the total contestants guided by Jameson Tomas (from step 1) using `1.0 * COUNT(*) / (subquery)` to ensure floating-point division and output the result as `prob`.",
        "type": 3,
        "idx": 2187
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Player_name = \"Fiona Shiells\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\" AND A.Player_name != \"Fiona Shiells\"",
        "englishquestion": "If Fiona Shiells won the first place instead, what is the probability of a contestant guided by Jameson Tomas winning the championship?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the count of contestants guided by Jameson Tomas who currently have 1st place rank and are not Fiona Shiells.  【step2】: Compute the numerator by adding the count from step1 and the hypothetical scenario where Fiona Shiells (if guided by Jameson Tomas) is included via a subquery.  【step3】: Determine the denominator by counting all contestants guided by Jameson Tomas, then divide the numerator by the denominator to calculate the probability.",
        "type": 4,
        "idx": 2188
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Player_name = \"Fiona Shiells\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" ) AS prob FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE C.Coach_name = \"Jameson Tomas\" AND A.Rank = \"1st\" AND A.Player_name != \"Fiona Shiells\"",
        "englishquestion": "Imagine if Fiona Shiells won the championship then what would the probability be for a contestant winning if they are guided by Jameson Tomas?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Count the number of contestants coached by Jameson Tomas who have already won the championship (Rank = '1st') excluding Fiona Shiells.  【step2】: Add the result from Step 1 to the hypothetical scenario where Fiona Shiells (if coached by Jameson Tomas) is also counted as a winner.  【step3】: Divide the combined count (Step 1 + Step 2) by the total number of contestants coached by Jameson Tomas to calculate the adjusted probability.",
        "type": 4,
        "idx": 2189
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) )",
        "englishquestion": "What's the name of the coach who has guided the most number of champions, and how many more has he produced than the coach who has guided the fewest?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of champions guided by each coach using a UNION to include coaches with zero champions. This creates a combined dataset of all coaches with their champion counts (either actual counts or 0).  【step2】: Identify the maximum champion count (n_1st) from the combined dataset to filter the top coach, and calculate the minimum champion count (n_1st) to determine the difference.  【step3】: Subtract the minimum champion count from the top coach’s count to get the difference, and output the coach’s name and this difference.",
        "type": 2,
        "idx": 2190
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Coach_name , n_1st - ( SELECT MIN ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) ) AS diff FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) WHERE n_1st = ( SELECT MAX ( n_1st ) FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) )",
        "englishquestion": "Find me the name of the coach with the most winning contestants and then find me how many more champions this coach has trained than the coach with the fewest winning contestants.",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate each coach's championship count (including coaches with 0 wins via UNION) through joined tables.  【step2】: Identify the coach with MAX(n_1st) and prepare MIN(n_1st) via subquery.  【step3】: Subtract MIN from MAX in final SELECT to output the championship difference.",
        "type": 2,
        "idx": 2191
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "englishquestion": "Coaches earn $100 for every champion they guided, $60 for every runner-up and $20 for every third-place finisher. What's the name of the coach who gets the most bonuses and how much does they earn?",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate each coach's number of 1st, 2nd, and 3rd-place players using three subqueries (t1, t2, t3). For coaches without players in a specific rank, use UNION to set their count to 0.  【step2】: Join these three subqueries by coach name to create a unified dataset containing all rank counts per coach.  【step3】: Compute the total bonus (100×n_1st + 60×n_2nd + 20×n_3rd), then select the coach with the highest bonus using MAX() and LIMIT 1 after sorting in descending order.",
        "type": 2,
        "idx": 2192
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "englishquestion": "Find me the name and bonus of the highest bonus earning coach if each champion earns $100, a runner-up earns $60 and a third place earns $20.",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate each coach's count of 1st place players (n_1st) via JOINs between player, player_coach, and coach tables, while ensuring coaches with zero 1st place players are included via UNION.  【step2】: Repeat the same logic as step1 separately for 2nd place (n_2nd) and 3rd place (n_3rd) counts, creating subqueries t2 and t3.  【step3】: JOIN subqueries t1, t2, t3 by Coach_name, compute total bonus (100*n_1st + 60*n_2nd + 20*n_3rd), then select the maximum value and corresponding coach using MAX() aggregation.",
        "type": 2,
        "idx": 2193
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND A.Player_name = \"Rachel Heinrichs\" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "englishquestion": "Coaches earn $100 for every champion they guided, $60 for every runner-up and $20 for every third-place finisher. If Rachel Heinrichs won the runner-up, what's the name of the coach who gets the most bonuses and how much does he earn?",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate each coach's number of 1st place wins (n_1st), including coaches with 0 wins via UNION to ensure all coaches are listed.  【step2】: Compute each coach's 2nd place count (n_2nd), excluding the coach of \"Rachel Heinrichs\" initially, then explicitly add her coach's count +1 to ensure her runner-up status is reflected. Simultaneously include coaches with 0 runner-ups.  【step3】: Derive each coach's 3rd place count (n_3rd), again including coaches with 0 via UNION. Join all three results (t1, t2, t3) by Coach_name, calculate total bonuses (100*n_1st +60*n_2nd +20*n_3rd), and select the coach with the MAX total earnings.",
        "type": 4,
        "idx": 2194
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT t1.Coach_name , MAX ( 100 * n_1st + 60 * n_2nd + 20 * n_3rd ) AS money FROM ( SELECT Coach_name , COUNT ( * ) AS n_1st FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"1st\" GROUP BY C.Coach_ID ) ) t1 JOIN ( SELECT Coach_name , COUNT ( * ) AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND C.Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" GROUP BY C.Coach_ID ) AND Coach_ID != ( SELECT C.Coach_ID FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) UNION SELECT ( SELECT C.Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Player_name = \"Rachel Heinrichs\" ) AS Coach_name , COUNT ( * ) + 1 AS n_2nd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"2nd\" AND A.Player_name = \"Rachel Heinrichs\" ) t2 ON t1.Coach_name = t2.Coach_name JOIN ( SELECT Coach_name , COUNT ( * ) AS n_3rd FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID UNION SELECT Coach_name , 0 FROM coach WHERE Coach_name NOT IN ( SELECT Coach_name FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON C.Coach_ID = B.Coach_ID WHERE A.Rank = \"3rd\" GROUP BY C.Coach_ID ) ) t3 ON t2.Coach_name = t3.Coach_name",
        "englishquestion": "What is the name and bonus of the coach with the highest bonus of Rachel Heinrichs won runner-up? Convert a champion into $100 bonus, a runner-up to $60 bonus and a third-place position to a $20 bonus.",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of 1st-place wins (n_1st) for each coach using a UNION to include coaches with zero 1st-place results.  【step2】: Compute the number of 2nd-place wins (n_2nd): exclude Rachel Heinrichs' coach from general counts, add an extra +1 to her coach's count via a UNION, and include coaches with zero 2nd-place results.  【step3】: Calculate 3rd-place wins (n_3rd) similarly to step 1, then join all subqueries to compute total bonuses and select the coach with the highest bonus using MAX().",
        "type": 4,
        "idx": 2195
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001",
        "englishquestion": "What percentage of clubs were established before the 21st century?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Calculate total number of clubs using subquery: (SELECT COUNT(*) FROM club).  【step2】: Count clubs established before 2001 with WHERE Start_year < 2001.  【step3】: Compute percentage via (filtered_count / total_count) * 100.0.",
        "type": 3,
        "idx": 2196
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001",
        "englishquestion": "What percentage of clubs were founded prior to the 21st Century?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Calculate the total number of clubs using a subquery: `(SELECT COUNT(*) FROM club)`.  【step2】: Count clubs founded before 2001 via `COUNT(*)` with a filter `WHERE Start_year < 2001`.  【step3】: Compute the percentage by dividing the pre-21st-century count by the total count and multiplying by `100.0` for decimal precision.",
        "type": 3,
        "idx": 2197
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = \"USA\" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != \"USA\"",
        "englishquestion": "If all the clubs in USA were established in 2000, what percentage of clubs were established before the 21st century?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Calculate the number of non-USA clubs established before 2001 using `COUNT(*)` with conditions `Start_year < 2001 AND Region != 'USA'`.  【step2】: Retrieve the total number of USA clubs via subquery `(SELECT COUNT(*) FROM club WHERE Region = 'USA')`, treating them as pre-21st-century clubs (since they are hypothetically set to 2000).  【step3】: Compute the final percentage by summing the results from Step1 and Step2, dividing by the global club count (via subquery `(SELECT COUNT(*) FROM club)`), and multiplying by 100.0 for percentage formatting.",
        "type": 4,
        "idx": 2198
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 100.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) FROM club WHERE Region = \"USA\" ) ) / ( SELECT COUNT ( * ) FROM club ) AS percent FROM club WHERE Start_year < 2001 AND Region != \"USA\"",
        "englishquestion": "What percentage of clubs were founded before the 21st Century given that all clubs in the USA were founded in 2000.",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Calculate the count of non-USA clubs founded before 2001 using `COUNT(*)` with filters `Start_year < 2001 AND Region != 'USA'`.  【step2】: Add the count of all USA clubs (implicitly founded in 2000 as per the problem statement) via the subquery `(SELECT COUNT(*) FROM club WHERE Region = 'USA')`.  【step3】: Divide the combined count by the total number of clubs (from the subquery `(SELECT COUNT(*) FROM club)`) and multiply by 100.0 to get the percentage.",
        "type": 4,
        "idx": 2199
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = \"Ross C. Martin\" )",
        "englishquestion": "What are the names of players living in the capital of Manitoba provincee in Cnanda received more than twice as many votes as Ross C. Martin?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Winnipeg is the capital of the Manitoba province of Canada.",
        "english_step": "【step1】: Determine the capital of Manitoba province in Canada, which is 'Winnipeg'.  【step2】: Retrieve Ross C. Martin's vote count via subquery: `SELECT Votes FROM player WHERE Player_name = 'Ross C. Martin'`.  【step3】: Filter players residing in Winnipeg with votes exceeding twice Ross C. Martin's votes using combined WHERE clause.",
        "type": 3,
        "idx": 2200
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * ( SELECT Votes FROM player WHERE Player_name = \"Ross C. Martin\" )",
        "englishquestion": "Of the players living in Manitona province's capital city, what are the names of players who received more than twice the votes that Ross C. Martin recieved?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Winnipeg is the capital of the Manitoba province of Canada.",
        "english_step": "【step1】: Retrieve the number of votes received by Ross C. Martin using a subquery: `(SELECT Votes FROM player WHERE Player_name = 'Ross C. Martin')`  【step2】: Calculate twice the retrieved votes (2 * subquery result) as the threshold value.  【step3】: Filter players residing in 'Winnipeg' (Manitona province's capital) whose votes exceed this threshold via `WHERE Residence = 'Winnipeg' AND Votes > [threshold]`.",
        "type": 3,
        "idx": 2201
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * 2000 AND Player_name != \"Ross C. Martin\"",
        "englishquestion": "What are the names of players living in the capital of Manitoba provincee in Cnanda received more than twice as many votes as Ross C. Martin, if Ross C. Martin obtained 2000 votes instead?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Winnipeg is the capital of the Manitoba province of Canada.",
        "english_step": "【step1】: Filter players residing in 'Winnipeg' (the capital of Manitoba, Canada).  【step2】: Apply a vote threshold of **4000** (twice Ross C. Martin's 2000 votes) using `Votes > 4000`.  【step3】: Exclude 'Ross C. Martin' explicitly with `Player_name != 'Ross C. Martin'` to finalize the results.",
        "type": 4,
        "idx": 2202
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT Player_name FROM player WHERE Residence = \"Winnipeg\" AND Votes > 2 * 2000 AND Player_name != \"Ross C. Martin\"",
        "englishquestion": "Of the players living in Manitona province's capital city, what are the names of players who received more than twice the votes that Ross C. Martin recieved, if if Ross C. Martin obtained 2000 votes instead?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Winnipeg is the capital of the Manitoba province of Canada.",
        "english_step": "【step1】: Filter players residing in 'Winnipeg' (the capital of Manitona province) using `WHERE Residence = 'Winnipeg'`.  【step2】: Apply the vote condition `Votes > 2 * 2000` to select players with votes exceeding twice Ross's 2000 votes.  【step3】: Exclude 'Ross C. Martin' explicitly using `Player_name <> 'Ross C. Martin'` to avoid including the player in the results.",
        "type": 4,
        "idx": 2203
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "englishquestion": "What are the names of the players whose coaches come from clubs established before the 21st Century, and how much higher are their votes than the lowest?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Filter clubs established before 2006 via `D.Start_year < 2006` and establish table connections (player→player_coach→coach→club)  【step2】: Match players to their coaches' clubs using JOINs on Player_ID→Coach_ID→Club_ID  【step3】: Calculate vote differential by subtracting the global minimum vote (subquery `SELECT MIN(Votes) FROM player`) from each player's votes",
        "type": 3,
        "idx": 2204
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT A.Player_name , A.Votes - ( SELECT MIN ( Votes ) FROM player ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "englishquestion": "Find me the names of players who have coaches that come from clubs established prior to the 21st Century and then calculate how much higher their respective votes are than the lowest number of votes.",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Perform INNER JOINs across player, player_coach, coach, and club tables to link players with their coaches' clubs. Apply the WHERE clause to filter clubs established before 2006.  【step2】: Execute the subquery `(SELECT MIN(Votes) FROM player)` to retrieve the absolute minimum vote value across all players.  【step3】: Calculate the difference (`diff`) between each filtered player's votes and the globally lowest votes, then project `Player_name` and `diff` in the final output.",
        "type": 3,
        "idx": 2205
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "englishquestion": "What are the names of players who are guided by coaches from clubs established before the 21st Century, and how much higher are their votes than the lowest if the lowest votes count is 1000?",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Filter clubs established before 2006 (21st Century cutoff based on the query) via `WHERE D.Start_year < 2006`.  【step2】: Join `club`, `coach`, `player_coach`, and `player` tables to link players with their coaches' clubs.  【step3】: Calculate the vote difference by subtracting 1000 from each player's votes (`A.Votes - 1000 AS diff`) and output the player names with this difference.",
        "type": 4,
        "idx": 2206
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT A.Player_name , A.Votes - 1000 AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID JOIN club D ON C.Club_ID = D.Club_ID WHERE D.Start_year < 2006",
        "englishquestion": "If the lowest vote count is 1000 then find what are the names of the players who have coaches from pre-21st-century clubs and calculate how much higher these players votes are than the minimum vote count.",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "The 21st century begins with 1 January 2001.",
        "english_step": "【step1】: Join tables (player, player_coach, coach, club) to link players with their coaches' clubs and filter clubs with Start_year < 2006.  【step2】: Apply the condition to select players whose coaches belong to pre-21st-century clubs (Start_year < 2006).  【step3】: Calculate the difference between each player's votes and the minimum vote count (1000), then return Player_name and the computed diff.",
        "type": 4,
        "idx": 2207
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = \"1st\"",
        "englishquestion": "What is the probability of a player without a coach winning the championship?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Identify all players without a coach by excluding those with entries in the `player_coach` table through a subquery using `Player_ID NOT IN (SELECT ... JOIN player_coach ... JOIN coach)`.  【step2】: Calculate the total count of players without a coach (denominator) and the count of such players who won the championship (`Rank = '1st'`, numerator) using filtered `WHERE` conditions.  【step3】: Compute the probability ratio by dividing the numerator by the denominator using `1.0 * COUNT(*) / (subquery)` to ensure floating-point precision.",
        "type": 3,
        "idx": 2208
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) AS ratio FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Rank = \"1st\"",
        "englishquestion": "If a player has no coach then how likely is it that they will win the championship?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Retrieve all players without a coach by excluding those with entries in the `player_coach` table via `Player_ID NOT IN (SELECT ... JOIN coach)`.  【step2】: Calculate the numerator (players without a coach *and* with `Rank` = '1st') and denominator (total players without a coach) using filtered subqueries.  【step3】: Compute the ratio by dividing the numerator by the denominator using `1.0 * COUNT(*) / (subquery)` to ensure floating-point division.",
        "type": 3,
        "idx": 2209
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" )",
        "englishquestion": "How much more likely is the coached player to finish in the top two than the uncoached player?",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the coached players' probability of finishing in the top two by dividing the number of coached top-two players by the total coached players.  【step2】: Calculate the uncoached players' probability similarly, using a subquery to exclude coached players and counting those in the top two.  【step3】: Subtract the uncoached probability from the coached probability to get the likelihood difference (`diff`).",
        "type": 3,
        "idx": 2210
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) - ( SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) ) FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) ) AS diff FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" )",
        "englishquestion": "What is the difference in likelihood of a coached player finishing in the top two versus an uncoached player?",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the proportion of coached players who finished in the top two: Join `player`, `player_coach`, and `coach` tables, count those with rank '1st' or '2nd', then divide by the total number of coached players.  【step2】: Calculate the proportion of uncoached players who finished in the top two: Identify players not in the coached subset via `NOT IN`, count those with rank '1st' or '2nd', then divide by the total number of uncoached players.  【step3】: Subtract the uncoached proportion from the coached proportion to get the likelihood difference (`diff`), using arithmetic operations on the two subquery results.",
        "type": 3,
        "idx": 2211
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) AND A.Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != \"Niki Ashton\" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != \"Niki Ashton\" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name != \"Niki Ashton\" )",
        "englishquestion": "If Niki Ashton was an uncoached player, how much more likely is the coached player to finish in the top two than the uncoached player?",
        "reasoning_type": "- + * / C H",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the probability (prob_1) of coached players (excluding Niki Ashton) finishing in the top two by:  - Counting coached top-two players (excluding Niki Ashton) in the numerator.  - Dividing by the total number of coached players (excluding Niki Ashton).  【step2】: Calculate the adjusted probability (prob_2) of uncoached players (assuming Niki Ashton is uncoached) by:  - Adding Niki Ashton’s top-two count to the numerator of uncoached top-two players.  - Adjusting the denominator to include her in the total uncoached player count.  【step3】: Subtract prob_2 from prob_1 to find the difference in likelihood (diff) between coached and uncoached players.",
        "type": 4,
        "idx": 2212
    },
    {
        "db_id": "exerciseclub",
        "query": "SELECT prob_1 - prob_2 AS diff FROM ( SELECT 1.0 * ( COUNT ( * ) - ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) AND A.Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE A.Player_name != \"Niki Ashton\" ) AS prob_1 FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID WHERE ( A.Rank = \"1st\" OR A.Rank = \"2nd\" ) ) JOIN ( SELECT 1.0 * ( COUNT ( * ) + ( SELECT COUNT ( * ) From player WHERE ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name = \"Niki Ashton\" ) ) / ( SELECT COUNT ( * ) + 1 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND Player_name != \"Niki Ashton\" ) AS prob_2 FROM player WHERE Player_ID NOT IN ( SELECT A.Player_ID AS player_with_coach FROM player A JOIN player_coach B ON A.Player_ID = B.Player_ID JOIN coach C ON B.Coach_ID = C.Coach_ID ) AND ( Rank = \"1st\" OR Rank = \"2nd\" ) AND Player_name != \"Niki Ashton\" )",
        "englishquestion": "How much likelier is it that a coached player ranks in the top two than a player without a coach if Niki Ashton has no coach?",
        "reasoning_type": "- + * / C H",
        "commonsense_knowledge": "A simple probability is calculated by dividing a specific outcome by all the possible outcomes.",
        "english_step": "【step1】: Calculate the probability (prob_1) of coached players (excluding Niki Ashton) ranking in the top two by:  - Subtracting the count of Niki Ashton (with a coach, if applicable) from coached top-two players.  - Dividing by the total coached players (excluding Niki Ashton).  【step2】: Calculate the probability (prob_2) of non-coached players (excluding Niki Ashton) ranking in the top two by:  - Adding the count of Niki Ashton (if non-coached and in the top two) to non-coached top-two players.  - Dividing by the total non-coached players (excluding Niki Ashton) + 1 (to account for potential inclusion logic).  【step3】: Compute the difference (diff) between prob_1 and prob_2 to determine the likelihood gap.",
        "type": 4,
        "idx": 2213
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "How much has Sterling spent so far?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join all relevant tables (Customers, Customer_Orders, Order_Items, Products) using appropriate foreign keys to link customer data with product price information.  【step2】: Filter the joined dataset to retain only records where the customer_name is 'Sterling'.  【step3】: Calculate the total expenditure by summing the product of order quantities and corresponding product prices for the filtered records.",
        "type": 3,
        "idx": 2214
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "What is the total spend for Sterling to date?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join all related tables (Customers, Customer_Orders, Order_Items, Products) via customer_id and order/product foreign keys.  【step2】: Filter the combined data to retain only records where customer_name = 'Sterling'.  【step3】: Calculate the sum of (order_quantity × product_price) across all matching records to get total spend.",
        "type": 3,
        "idx": 2215
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name = \"gucci\" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name != \"gucci\" )",
        "englishquestion": "If the unit price of all Gucci products is 600, how much has Sterling spent so far?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the cost of 'Gucci' products using the fixed unit price of 600. Join relevant tables (Customers, Customer_Orders, Order_Items, Products), filter for 'Sterling' and 'gucci', then compute SUM(order_quantity * 600).  【step2】: Calculate the cost of non-'Gucci' products using original prices. Use the same joins but filter for 'Sterling' and product_name ≠ 'gucci', computing SUM(order_quantity * product_price).  【step3】: Combine both results via UNION (ensuring no duplicates), then aggregate the total sum from the combined subquery using an outer SUM(cost).",
        "type": 4,
        "idx": 2216
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( cost ) FROM ( SELECT SUM ( C.order_quantity * 600 ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name = \"gucci\" UNION SELECT SUM ( C.order_quantity * D.product_price ) AS ost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\" AND product_name != \"gucci\" )",
        "englishquestion": "Calculate Sterling's total spend to date if all Gucci products cost 600 each.",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the cost for all 'Gucci' products ordered by Sterling using the fixed price of 600 per unit by joining Customers, Customer_Orders, Order_Items, and Products tables with conditions **customer_name = 'Sterling'** and **product_name = 'gucci'**, then multiply order_quantity by 600.  【step2】: Calculate the cost for non-'Gucci' products ordered by Sterling using the original product_price by joining the same tables with conditions **customer_name = 'Sterling'** and **product_name != 'gucci'**, then multiply order_quantity by product_price.  【step3】: Combine the two results using **UNION** to merge both cost calculations into a single column, then apply an outer **SUM()** to aggregate the total spend across all products (both Gucci and non-Gucci).",
        "type": 4,
        "idx": 2217
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "Sterling is a member and gets a 20% discount on all products. How much has he spent so far?",
        "reasoning_type": "* C - /",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join `Customers` (A) with `Customer_Orders` (B) via `customer_id` to identify all orders placed by customer 'Sterling'.  【step2】: Link the result to `Order_Items` (C) and `Products` (D) via `order_id` and `product_id` respectively, obtaining product prices and quantities.  【step3】: Calculate total expenditure by summing `order_quantity * product_price` with a 20% discount applied, aliased as `cost_after_discount`.",
        "type": 3,
        "idx": 2218
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 - 1.0 * 20 / 100 ) ) AS cost_after_discount FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "Calculate Sterling's spend to date factoring in a 20% member price discount.",
        "reasoning_type": "* C - /",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join `Customers` and `Customer_Orders` on `customer_id` to link Sterling's orders.  【step2】: Join `Order_Items` and `Products` on `product_id` to access product prices and quantities.  【step3】: Calculate total spend using `SUM` with a 20% discount applied to `product_price` multiplied by `order_quantity`, filtered by `customer_name = 'Sterling'`.",
        "type": 3,
        "idx": 2219
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "Sterling is a member and gets a 20% discount on all products. How much has he saved so far?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join the Customers, Customer_Orders, Order_Items, and Products tables using customer_id, order_id, and product_id relationships.  【step2】: Filter records where customer_name is 'Sterling' to isolate his orders.  【step3】: Calculate total savings by summing 20% of (order_quantity * product_price) across all matching entries.",
        "type": 3,
        "idx": 2220
    },
    {
        "db_id": "contract",
        "query": "SELECT SUM ( C.order_quantity * D.product_price * ( 1.0 * 20 / 100 ) ) AS svaed_money FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Sterling\"",
        "englishquestion": "Calculate how much Sterling has saved to date through their 20% member price discount.",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join the Customers table (A) with Customer_Orders (B) using customer_id to identify Sterling's orders.  【step2】: Join Order_Items (C) to get product quantities and Products (D) to access prices for each ordered item.  【step3】: Calculate the total discount savings by summing (quantity × price × 20%) for all matching records filtered by customer_name = 'Sterling'.",
        "type": 3,
        "idx": 2221
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC",
        "englishquestion": "List customer IDs, names, addresses, phone numbers, and email addresses in descending order of their total spending to date.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join customer, order, and product tables to link customer details with purchased item data.  【step2】: Calculate total spending per customer by summing the product of order quantities and prices.  【step3】: Group results by customer attributes and sort by total spending in descending order.",
        "type": 3,
        "idx": 2222
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_id , A.customer_name , A.customer_address , A.customer_phone , A.customer_email , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id GROUP BY A.customer_name ORDER BY cost DESC",
        "englishquestion": "Sort customers by descending order of total spending to today and give me the total spend, name, email address, phone number, mail address and customer ID.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join all related tables (Customers, Customer_Orders, Order_Items, Products) using their foreign keys to consolidate customer information with order quantities and product prices.  【step2】: Group the joined data by customer attributes (customer_id, name, address, phone, email) and calculate total spending using SUM(order_quantity * product_price).  【step3】: Sort the grouped results in descending order of the calculated total spending (cost).",
        "type": 3,
        "idx": 2223
    },
    {
        "db_id": "contract",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "englishquestion": "What is the total price of Cleo's latest order?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join the Customers, Customer_Orders, Order_Items, and Products tables to gather all relevant order details for Cleo.  【step2】: Calculate the total cost per order (grouped by order_id) by multiplying product quantities and prices, then filter for Cleo using WHERE A.customer_name = 'Cleo'.  【step3】: Sort the results by order_date in descending order and select the top entry (LIMIT 1) to retrieve the latest order's total price.",
        "type": 3,
        "idx": 2224
    },
    {
        "db_id": "contract",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( C.order_quantity * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "englishquestion": "Calculate the sum price of the lastest order from Cleo.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join the `Customers`, `Customer_Orders`, `Order_Items`, and `Products` tables to gather order details and product prices for customer 'Cleo'.  【step2】: Calculate the total cost per order (`SUM(C.order_quantity * D.product_price)`) grouped by `order_id`, generating a temporary result set (`subquery`).  【step3】: Sort the temporary results by `order_date` in descending order and select the top entry (`LIMIT 1`) to retrieve the cost of the most recent order.",
        "type": 3,
        "idx": 2225
    },
    {
        "db_id": "contract",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "englishquestion": "What is the total price of Cleo's latest order if he purchased 5 of each product?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join tables (Customers, Customer_Orders, Order_Items, Products) using respective IDs, filter for customer_name = 'Cleo'.  【step2】: Group by order_id to calculate total price per order by summing 5×product_price for all products in each order.  【step3】: Sort results by order_date descending and select the top entry to retrieve the latest order's total cost.",
        "type": 4,
        "idx": 2226
    },
    {
        "db_id": "contract",
        "query": "SELECT cost FROM ( SELECT B.order_date , SUM ( 5.0 * D.product_price ) AS cost FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.customer_name = \"Cleo\" GROUP BY C.order_id ) ORDER BY order_date DESC LIMIT 1",
        "englishquestion": "If Cleo purchased 5 of each product, then what is the total cost of Cleo's latest order?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Retrieve Cleo's orders with product details by joining Customers, Customer_Orders, Order_Items, and Products tables.  【step2】: Calculate total cost per order (5 units × product_price for each item) and group by order_id.  【step3】: Sort results by order_date descending and extract the latest order's total cost using LIMIT 1.",
        "type": 4,
        "idx": 2227
    },
    {
        "db_id": "contract",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "englishquestion": "The cost of Apple products is 40% of the selling price, Gucci products is 20% of the selling price, and other products is 50% of the selling price. Please list each product's ID, name, sales volume, sales revenue, and total gross profit.",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity. Gross profit is calculated by substracting costs of goods from revenue.",
        "english_step": "【step1】: Calculate sales metrics for 'Apple' products: Join Order_Items with Products, filter by product_name='Apple', group by product_id, compute SUM(order_quantity) as quantity, SUM(quantity×price) as revenue, and apply 40% cost (60% profit margin) to calculate profit.  【step2】: Calculate metrics for 'Gucci' and other products using similar logic: Two separate UNION blocks handle 'Gucci' (20% cost → 80% margin) and non-Apple/Gucci products (50% cost → 50% margin) with respective WHERE/NOT IN filters.  【step3】: Include unsold products: Use LEFT JOIN to find products without Order_Items entries, set quantity/revenue/profit to 0, then UNION with previous results to ensure all products are listed.",
        "type": 3,
        "idx": 2228
    },
    {
        "db_id": "contract",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "englishquestion": "List all products and product ID, name, volume of sales, sales revenue and total gross profit if Apple products cost 40% of selling price, Gucci products cost 20% of selling price and all other products cost half their sale price.",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity. Gross profit is calculated by substracting costs of goods from revenue.",
        "english_step": "【step1】: Calculate Apple product metrics: JOIN Order_Items and Products, filter by 'Apple', group by product_id, apply 40% cost to compute profit.  【step2】: Process Gucci products similarly via UNION: filter by 'gucci', use 20% cost formula, maintain group aggregation.  【step3】: Merge results for non-Apple/Gucci products (50% cost) and unsold products (zero sales data) using UNION, ensuring full product coverage.",
        "type": 3,
        "idx": 2229
    },
    {
        "db_id": "contract",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "englishquestion": "The cost of Apple products is 40% of the selling price, Gucci products is 20% of the selling price, and other products is 50% of the selling price. If all Apple products are discounted by 15%, please list each product's ID, name, sales volume, sales revenue, and total gross profit.",
        "reasoning_type": "- * / C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity. Gross profit is calculated by substracting costs of goods from revenue.",
        "english_step": "【step1】: Process Apple products with a 15% discount: Join Order_Items and Products, filter 'Apple' products, apply 15% discount on price, calculate revenue and profit (40% cost ratio), then aggregate by product.  【step2】: Handle Gucci and other products separately: Use UNION to combine three segments - Gucci products with 20% cost ratio, non-Apple/non-Gucci products with 50% cost ratio (both without discount), aggregating sales data similarly.  【step3】: Include unsold products: Use LEFT JOIN to find products without orders, set quantity/revenue/profit to 0, then UNION with previous results to ensure all products are listed.",
        "type": 4,
        "idx": 2230
    },
    {
        "db_id": "contract",
        "query": "SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) AS revenue , SUM ( A.order_quantity * ( B.product_price * ( 1.0 - 15.0 / 100 ) ) ) * ( 1.0 - 40.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"Apple\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 20.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name = \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , SUM ( A.order_quantity ) AS quantity , SUM ( A.order_quantity * B.product_price ) AS revenue , SUM ( A.order_quantity * B.product_price ) * ( 1.0 - 50.0 / 100 ) AS profit FROM Order_Items A JOIN Products B ON A.product_id = B.product_id WHERE B.product_name != \"Apple\" AND B.product_name != \"gucci\" GROUP BY B.product_id UNION SELECT B.product_id , B.product_name , 0 , 0 , 0 FROM ( SELECT product_id FROM Products A EXCEPT SELECT B.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id ) A JOIN Products B ON A.product_id = B.product_id",
        "englishquestion": "During an Apple sale discounting all product selling price by 15%, list all products and name, sales volume, product ID, revenue of sales and total profit gross if Apple products cost 40% of selling price, Gucci products cost 20% of selling price and all other products cost half their sale price.",
        "reasoning_type": "- * / C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity. Gross profit is calculated by substracting costs of goods from revenue.",
        "english_step": "【step1】: Calculate discounted revenue and profit for Apple products: Apply a 15% discount, use 40% cost rate (profit=60% of discount price), aggregate sales data with JOIN on product_id.  【step2】: Process Gucci and other products with UNION:  - Gucci: No discount, 20% cost rate (profit=80% of original price)  - Others: No discount, 50% cost rate (profit=50% of original price)  【step3】: Include unsold products via subquery: Use NOT EXISTS to find products without orders, set quantity/revenue/profit=0, and UNION with previous results.",
        "type": 4,
        "idx": 2231
    },
    {
        "db_id": "contract",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = \"Completed\"",
        "englishquestion": "What percentage of orders have been completed?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of orders by using the subquery `(SELECT COUNT(*) FROM Customer_Orders)`.  【step2】: Count the completed orders with `WHERE order_status_code = 'Completed'` in the main query.  【step3】: Compute the percentage by dividing completed orders (from step2) by total orders (from step1), then multiply by 100 and convert to a float using `1.0 *`.",
        "type": 2,
        "idx": 2232
    },
    {
        "db_id": "contract",
        "query": "SELECT 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE order_status_code = \"Completed\"",
        "englishquestion": "Of total orders, what percentage are completed?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of orders using the subquery: `SELECT COUNT(*) FROM Customer_Orders`.  【step2】: Count completed orders by filtering with `WHERE order_status_code = 'Completed'`.  【step3】: Compute the percentage by dividing completed orders by total orders (from step1 and step2), then multiply by 100 and ensure floating-point division with `1.0 *`.",
        "type": 2,
        "idx": 2233
    },
    {
        "db_id": "contract",
        "query": "SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( \"%Y\" , order_date ) >= \"2000\" AND order_status_code != \"Completed\"",
        "englishquestion": "If all orders before year 2000 have been completed, what percentage of orders have been completed?",
        "reasoning_type": "- * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate total number of orders using a subquery: `(SELECT COUNT(*) FROM Customer_Orders)`  【step2】: Count orders from year 2000 onward that are **not** completed: `COUNT(*) WHERE YEAR(order_date) >= 2000 AND order_status_code != 'Completed'`  【step3】: Compute percentage by subtracting non-completed orders' ratio from 100: `100 - (step2_result / step1_result * 100)`",
        "type": 4,
        "idx": 2234
    },
    {
        "db_id": "contract",
        "query": "SELECT 100 - 1.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM Customer_Orders ) * 100 AS percent FROM Customer_Orders WHERE strftime ( \"%Y\" , order_date ) >= \"2000\" AND order_status_code != \"Completed\"",
        "englishquestion": "Of total orders, what percentage are completed assuming all pre-2000 orders are completed?",
        "reasoning_type": "- * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of orders using a subquery: `(SELECT COUNT(*) FROM Customer_Orders)`.  【step2】: Count post-2000 orders that are *not* completed with `COUNT(*)` filtered by `YEAR(order_date) >= 2000 AND order_status_code != 'Completed'`.  【step3】: Compute the inverse percentage (subtracting non-completed post-2000 orders from total) via `100 - (step2 / step1 * 100)` to derive the percentage of \"completed\" orders under the assumption.",
        "type": 4,
        "idx": 2235
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "englishquestion": "What are the names of users with multiple contact methods and the amount of their first order?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the total price of each order by joining Order_Items, Customer_Orders, and Products. Group by customer_id and order_id to get SUM(A.order_quantity * C.product_price) as price.  【step2】: Filter customers with multiple contacts via a subquery on Contacts (HAVING COUNT(*) > 1), then join with Customers to append customer_name. Group by customer_id and include MIN(order_date) to identify the earliest order.  【step3】: Extract customer_name and price from the derived table, where the grouping in step2 ensures only the first order's price (linked to the earliest order_date) is retained per customer.",
        "type": 3,
        "idx": 2236
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "englishquestion": "Tell me the names and first order cost of users only with multiple contact methods?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the total cost (price) for each order by joining Order_Items, Customer_Orders, and Products, grouping by customer_id and order_id.  【step2】: Filter customers with multiple contact methods (via subquery on Contacts) and join with Customers to get names, retaining only relevant fields.  【step3】: Group results by customer_id, use ANY_VALUE() to fetch non-grouped fields (name and price), and wrap everything in an outer query for final projection.",
        "type": 3,
        "idx": 2237
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = \"Apple\" AND strftime ( \"%Y\" , B.order_date ) < \"2000\" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != \"Apple\" OR strftime ( \"%Y\" , B.order_date ) >= \"2000\" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "englishquestion": "If all Apple products before year 2000 were priced at 888, what is the amount of the first order for users with multiple contact methods?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate order prices by splitting into two scenarios: (1) Apple products before 2000 use fixed price 888, (2) others use original price. Combine results via UNION and aggregate per order.  【step2】: Join with Customers table, filter users with >1 contact method using subquery on Contacts table.  【step3】: For qualifying users, find earliest order date per customer via MIN(order_date), then extract corresponding price and customer name in final output.",
        "type": 4,
        "idx": 2238
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name , price FROM ( SELECT M.customer_id , N.customer_name , M.price , MIN ( M.order_date ) FROM ( SELECT customer_id , order_id , order_date , SUM ( price ) AS price FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * 888.0 ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name = \"Apple\" AND strftime ( \"%Y\" , B.order_date ) < \"2000\" GROUP BY B.customer_id , B.order_id UNION SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id WHERE C.product_name != \"Apple\" OR strftime ( \"%Y\" , B.order_date ) >= \"2000\" GROUP BY B.customer_id , B.order_id ) GROUP BY customer_id , order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Contacts GROUP BY customer_id HAVING COUNT ( * ) > 1 ) GROUP BY M.customer_id )",
        "englishquestion": "Tell me the amount of the initial order only for users with multiple contact methods if all Apple products cost 888 before 2000?",
        "reasoning_type": "* C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate order prices by splitting into two scenarios: (1) Apple products before 2000 with fixed price 888, (2) Non-Apple products or orders after 2000 with original prices using UNION. Group by customer_id and order_id.  【step2】: Join with Customers table, filter users with multiple contacts via subquery (customer_id in Contacts with COUNT > 1), and aggregate per customer to retain MIN(order_date).  【step3】: Wrap in outer query to explicitly select customer_name and price, ensuring only the earliest order's price for qualifying users is returned.",
        "type": 4,
        "idx": 2239
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)",
        "englishquestion": "What are the names of users who have had multiple different addresses, and which postcode have they used the longest?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to associate address details and customer names with usage periods.  【step2】: Group by customer_id, calculate the duration of each address usage (DATEDIFF), and filter for users with >1 addresses (HAVING COUNT(*) > 1). Track the maximum usage duration per customer.  【step3】: Select the customer_name and zip_postcode from the subquery, implicitly returning the zip_postcode linked to the longest-dated address entry via MAX(DATEDIFF).",
        "type": 3,
        "idx": 2240
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_name, zip_postcode FROM (SELECT C.customer_name, B.zip_postcode, MAX (julianday (A.date_to) - julianday (A.date_from)) FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) > 1)",
        "englishquestion": "Tell me the names of users who have held multiple addresses on file and which postcode each user has held the longest?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to link user details, addresses, and address durations.  【step2】: Group by customer_id, calculate the maximum address duration (DATEDIFF), and filter users with multiple addresses (HAVING COUNT(*) > 1).  【step3】: Extract the customer_name and corresponding zip_postcode associated with the longest recorded duration from the grouped results.",
        "type": 3,
        "idx": 2241
    },
    {
        "db_id": "contract",
        "query": "SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1",
        "englishquestion": "What are the names of users have never had multiple different addresses, and which postcode have they used?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Join the Customer_Address_History, Addresses, and Customers tables to link user information with their address records.  【step2】: Group the results by customer_id to count how many distinct address entries each user has in their history.  【step3】: Apply a HAVING clause to filter only users with exactly 1 address record, then return their name and associated postcode.",
        "type": 3,
        "idx": 2242
    },
    {
        "db_id": "contract",
        "query": "SELECT C.customer_name, B.zip_postcode FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Customers C ON C.customer_id = A.customer_id GROUP BY A.customer_id HAVING COUNT (*) = 1",
        "englishquestion": "Tell me the names of users who have never had more than 1 address at any given time and which postcode each user held?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Join Customer_Address_History, Addresses, and Customers tables to link user data with address details and postal codes.  【step2】: Group results by customer_id to aggregate address history entries per user.  【step3】: Filter groups using HAVING COUNT(*) = 1 to retain only users with exactly one permanent address record.",
        "type": 3,
        "idx": 2243
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( \"%Y\" , MAX ( order_date ) ) < \"2000\" ) GROUP BY M.customer_id )",
        "englishquestion": "Which user has not placed an order since 2000? List their ID, name, email, and the amount of their last order.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the total price of each order by joining Order_Items, Customer_Orders, and Products, grouping by customer_id and order_id.  【step2】: Filter customers whose last order was before 2000 using a subquery, then join with Customers to get their details and derive the last_order_price via MAX(order_date).  【step3】: Output the final result by selecting customer_id, name, email, and the price of their last order from the aggregated subquery.",
        "type": 3,
        "idx": 2244
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_id , customer_name , customer_email , price AS last_order_price FROM ( SELECT M.customer_id , N.customer_name , N.customer_email , M.price , MAX ( M.order_date ) FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) M JOIN Customers N ON M.customer_id = N.customer_id WHERE M.customer_id IN ( SELECT customer_id FROM Customer_Orders GROUP BY customer_id HAVING strftime ( \"%Y\" , MAX ( order_date ) ) < \"2000\" ) GROUP BY M.customer_id )",
        "englishquestion": "Tell me the name, email, customer ID and most recent order total of users who have not ordered anything since 2000?",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Compute the total price of each historical order by joining Order_Items, Customer_Orders, and Products tables. Group by customer_id and order_id to calculate order_quantity × product_price sums.  【step2】: Filter customers whose last order was before 2000 using a subquery on Customer_orders (GROUP BY customer_id + HAVING YEAR(MAX(order_date)) < 2000), then join with Customers table to attach customer details.  【step3】: For qualifying customers, retrieve their most recent order total by grouping results from Step 2 by customer_id and selecting the MAX(order_date) along with the associated price.",
        "type": 3,
        "idx": 2245
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1",
        "englishquestion": "Users can earn 222 points for a single order with a total price of over 1000 and another 666 points for a total price of over 2000. Which user currently has the most total points? Give me their ID.",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the total price per order by joining Order_Items, Customer_Orders, and Products, then group by customer_id and order_id.  【step2】: Split into two subqueries:  - For orders over 2000: count each as 888 points (222+666).  - For orders between 1000-2000: count each as 222 points.  【step3】: Combine results via UNION, aggregate total points per user, sort descendingly, and return the top customer_id.",
        "type": 3,
        "idx": 2246
    },
    {
        "db_id": "contract",
        "query": "SELECT customer_id FROM ( SELECT customer_id , COUNT ( * ) * ( 666 + 222 ) AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 2000 GROUP BY customer_id UNION SELECT customer_id , COUNT ( * ) * 222 AS points FROM ( SELECT B.customer_id , B.order_id , B.order_date , SUM ( A.order_quantity * C.product_price ) AS price FROM Order_Items A JOIN Customer_Orders B ON A.order_id = B.order_id JOIN Products C ON C.product_id = A.product_id GROUP BY B.customer_id , B.order_id ) WHERE price > 1000 AND price < 2000 GROUP BY customer_id ) GROUP BY customer_id ORDER BY points DESC LIMIT 1",
        "englishquestion": "Tell me the ID of the user with the most total points if all orders over 1000 earn 222 points and orders over 2000 earn and additional 666 points?",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate the total price per order by joining Order_Items, Customer_Orders, and Products. Group by customer_id and order_id to compute SUM(order_quantity * product_price).  【step2】: Split into two subqueries: orders over 2000 (assign 888 points each via COUNT * 888) and orders between 1000-2000 (assign 222 points each via COUNT * 222). Combine results with UNION.  【step3】: Aggregate combined points by customer_id, sort by descending total points, and select the top customer_id with LIMIT 1.",
        "type": 3,
        "idx": 2247
    },
    {
        "db_id": "contract",
        "query": "SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "englishquestion": "How much higher is the average unit price of clothing compared to hardware?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average price of hardware products using a subquery with alias 'a'  【step2】: Calculate the average price of clothing products using another subquery with alias 'b'  【step3】: Compute the difference between the two averages via CROSS JOIN of subquery results",
        "type": 2,
        "idx": 2248
    },
    {
        "db_id": "contract",
        "query": "SELECT clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "englishquestion": "Calculate the difference in average prices between clothing and hardware?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average price of Hardware products in subquery t1.  【step2】: Calculate the average price of Clothes products in subquery t2.  【step3】: Perform a JOIN between t1 and t2 (implicit cross join) and compute the difference between the two averages as diff.",
        "type": 2,
        "idx": 2249
    },
    {
        "db_id": "contract",
        "query": "SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "englishquestion": "If clothing prices increase by 20%, how much higher is the average unit price of clothing compared to hardware?",
        "reasoning_type": "+ * - / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average price for Hardware products using a subquery with alias 'hw'  【step2】: Calculate the original average price for Clothes products using a subquery with alias 'clothes', then perform CROSS JOIN between both subquery results  【step3】: Compute the price difference by applying the 20% increase to clothes_avg before subtracting hw_avg, using explicit floating-point arithmetic (20.0)",
        "type": 4,
        "idx": 2250
    },
    {
        "db_id": "contract",
        "query": "SELECT ( 1 + 20.0 / 100 ) * clothes_avg - hw_avg AS diff FROM ( SELECT AVG ( product_price ) AS hw_avg FROM Products WHERE product_type_code = \"Hardware\" ) JOIN ( SELECT AVG ( product_price ) AS clothes_avg FROM Products WHERE product_type_code = \"Clothes\" )",
        "englishquestion": "Calculate how much higher the difference in average price is between clothing and hardware if clothing prices increase by 20%?",
        "reasoning_type": "+ * - / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the average price of hardware products (hw_avg) using a subquery filtering by product_type_code = 'Hardware'.  【step2】: Calculate the current average price of clothing products (clothes_avg) using another subquery filtering by product_type_code = 'Clothes'.  【step3】: Perform a CROSS JOIN between the two subquery results, then compute the adjusted difference as (1.2 * clothes_avg) - hw_avg to account for the 20% price increase.",
        "type": 4,
        "idx": 2251
    },
    {
        "db_id": "contract",
        "query": "SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = \"Kentucky\" AND C.gender = \"female\" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = \"Kentucky\" )",
        "englishquestion": "How many users have used an address in a state with a capital city of Frankfurt, and what is the proportion of females among them?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Frankfort is the capital city of Kentucky state.",
        "english_step": "【step1】: Calculate the total number of distinct users who have used addresses in the state 'Kentucky' by joining **Customer_Address_History** and **Addresses** tables, filtering on `state_province_county = 'Kentucky'`.  【step2】: Calculate the number of distinct female users in the same state by joining **Customer_Address_History**, **Addresses**, and **Contacts** tables, filtering on `state_province_county = 'Kentucky'` and `gender = 'female'`.  【step3】: Combine the results of the two subqueries via **JOIN** (implicit Cartesian join) and compute the female ratio using `1.0 * n_female / n_total`.",
        "type": 3,
        "idx": 2252
    },
    {
        "db_id": "contract",
        "query": "SELECT n_total , 1.0 * n_female / n_total AS female_ratio FROM ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_female FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id JOIN Contacts C ON A.customer_id = C.customer_id WHERE B.state_province_county = \"Kentucky\" AND C.gender = \"female\" ) JOIN ( SELECT COUNT ( DISTINCT ( A.customer_id ) ) AS n_total FROM Customer_Address_History A JOIN Addresses B ON A.address_id = B.address_id WHERE B.state_province_county = \"Kentucky\" )",
        "englishquestion": "What is the total number of users in the state with Frankfurt as the capital city? What proportion of this total are females?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Frankfort is the capital city of Kentucky state.",
        "english_step": "【step1】: Retrieve total number of distinct users in Kentucky state by joining Customer_Address_History and Addresses tables, filtering with B.state_province_county = 'Kentucky'.  【step2】: Calculate female users count in Kentucky state by adding Contacts table join with C.gender = 'female' filter while keeping other conditions consistent.  【step3】: Cross-join the two aggregated results (total & female counts) and compute female ratio via 1.0 * n_female / n_total in the final SELECT projection.",
        "type": 3,
        "idx": 2253
    },
    {
        "db_id": "contract",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "englishquestion": "What are the ID, name, and sales volume of the product that has the highest sales volume, and how much higher is it compared to the product with the lowest sales volume?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Generate a dataset including all products with their total sales volume (sum of order_quantity) and products without orders (assigned 0 sales) using a UNION between grouped Order_Items and unlisted Products.  【step2】: Calculate the difference between the maximum and minimum sales volumes using the same UNION-derived dataset from Step 1 via a nested subquery.  【step3】: Join the aggregated product data (Step 1) with the precomputed sales difference (Step 2), then filter to return the product row with the MAX(quantity) alongside the global difference value.",
        "type": 2,
        "idx": 2254
    },
    {
        "db_id": "contract",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) AS max_quantity , t2.diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "englishquestion": "Find me the product ID and name with the highest volume of sales, and tell me its sales volumne, and how much higher this volume is than the product with the lowest sales volume?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Generate sales data for all products (including those with zero sales by using UNION to combine actual sales from Order_Items and zero entries for unsold products from Products).  【step2】: Calculate the difference between maximum and minimum sales volumes (MAX(quantity) - MIN(quantity)) using the dataset created in Step 1.  【step3】: Join the sales data (Step1) with the calculated difference (Step2), then select the product with MAX(quantity) to output its ID, name, sales volume, and the volume difference.",
        "type": 2,
        "idx": 2255
    },
    {
        "db_id": "contract",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "englishquestion": "What are the ID and name of product that has the highest sales volume? If its sales volume was increased by 500, what is its sales volume and how much higher is it compared to the product with the lowest sales volume?",
        "reasoning_type": "- + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate sales volume for all products (including products with 0 sales via UNION) by joining Order_Items and Products, grouping by product_id and product_name.  【step2】: Compute the difference between max and min sales volumes (diff) from the same aggregated dataset generated in step1.  【step3】: Combine results from step1 and step2 via JOIN, then project product_id, product_name, max sales+500, and diff+500 using GROUP BY on product attributes and precomputed diff.",
        "type": 4,
        "idx": 2256
    },
    {
        "db_id": "contract",
        "query": "SELECT t1.product_id , t1.product_name , MAX ( t1.quantity ) + 500 AS max_quantity , t2.diff + 500 FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) t1 JOIN ( SELECT MAX ( quantity ) - MIN ( quantity ) AS diff FROM ( SELECT A.product_id , B.product_name , SUM ( order_quantity ) AS quantity FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id UNION SELECT product_id , product_name , 0 AS quantity FROM Products WHERE product_id NOT IN ( SELECT A.product_id FROM Order_Items A JOIN Products B ON A.product_id = B.product_id GROUP BY A.product_id ) ) ) t2",
        "englishquestion": "Find me the ID and name of the product with the highest sales volume. What would its sales volume be if it increased by 500, and how much higher would its sale volume be , relative to the product with lowest sale?",
        "reasoning_type": "- + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Generate a temporary table (t1) containing all products, combining those with sales data (summing order_quantity) and those without sales (quantity set to 0) using UNION.  【step2】: Calculate the difference (diff) between the highest and lowest sales volumes from the same temporary dataset (t1) via subquery t2.  【step3】: Select the product with the highest sales volume from t1, add 500 to its quantity, and append the pre-computed diff value (also incremented by 500) from t2 via a cross join.",
        "type": 4,
        "idx": 2257
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "englishquestion": "A 5% service charge is required for credit card payments. List the name of each customer and how much each customer spent on each order along with the order id.",
        "reasoning_type": "+ * / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate order costs with 5% fee for credit card users by joining Customers, Customer_Orders, Order_Items, and Products tables. Apply (quantity × price) × 1.05 formula and filter via WHERE payment_method_code='Credit Card'.  【step2】: Calculate regular order costs (without fee) for non-credit-card users using the same tables but with WHERE payment_method_code≠'Credit Card'.  【step3】: Combine both results using UNION to display all customers' order costs with appropriate fee logic based on payment method.",
        "type": 3,
        "idx": 2258
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * D.product_price ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * D.product_price AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "englishquestion": "Tell me the name of each customer and how much each customer spent on each order along with the order id, if a 5% service charge is required for all credit card payments.",
        "reasoning_type": "+ * / C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join Customers, Customer_Orders, Order_Items, and Products tables. Calculate order costs with 5% service fee for credit card payments, grouping by customer_name and order_id.  【step2】: Repeat the join but exclude credit card payments, calculating raw order costs without service fee, grouping by customer_name and order_id.  【step3】: Combine both result sets using UNION to display credit card orders with fees and non-credit-card orders without fees in final output.",
        "type": 3,
        "idx": 2259
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "englishquestion": "A 5% service charge is required for credit card payments. If the unit price of each product is 99, list the name of each customer and how much each customer spent on each order along with the order id.",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Calculate credit card orders with 5% service charge by joining relevant tables (Customers, Customer_Orders, Order_Items) and applying formula (quantity*99)*1.05. Filter using payment_method_code='Credit Card' and group by customer+order.  【step2】: Calculate non-credit card orders with base price using same table joins but exclude credit card payments, applying formula (quantity*99).  【step3】: Combine both credit card and non-credit card results using UNION to produce final unified output.",
        "type": 4,
        "idx": 2260
    },
    {
        "db_id": "contract",
        "query": "SELECT A.customer_name , B.order_id , ( C.order_quantity * 99 ) * ( 1 + 5.0 / 100 ) AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code = \"Credit Card\" GROUP BY A.customer_name , B.order_id UNION SELECT A.customer_name , B.order_id , C.order_quantity * 99 AS cost_plus_fee FROM Customers A JOIN Customer_Orders B ON A.customer_id = B.customer_id JOIN Order_Items C ON B.order_id = C.order_id JOIN Products D ON C.product_id = D.product_id WHERE A.payment_method_code != \"Credit Card\" GROUP BY A.customer_name , B.order_id",
        "englishquestion": "Tell me the name of each customer and how much each customer spent on each order along with the order id, given that the unit price of all products is 99 and we charge a 5% fee for credit card payments.",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Retrieve credit card orders: Join Customers, Customer_Orders, Order_Items, and Products tables. Calculate total cost with 5% fee using (order_quantity * 99 * 1.05). Filter by credit card payments and group by customer_name + order_id.  【step2】: Retrieve non-credit card orders: Repeat joins but filter out credit card payments. Calculate cost without fee using (order_quantity * 99), group by customer_name + order_id.  【step3】: Combine results using UNION to merge credit/non-credit order data into final output with consistent column structure.",
        "type": 4,
        "idx": 2261
    },
    {
        "db_id": "contract",
        "query": "SELECT strftime ( \"%Y\" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( \"%Y\" , A.order_date )",
        "englishquestion": "List the year in record and the annual sales revenue for each year.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join tables Customer_Orders (A), Order_Items (B), and Products (C) via order_id and product_id to link order details with product prices.  【step2】: Calculate sales revenue per transaction by multiplying B.order_quantity by C.product_price.  【step3】: Group results by YEAR(A.order_date) and sum the per-transaction revenue to derive annual_sales_revenue.",
        "type": 3,
        "idx": 2262
    },
    {
        "db_id": "contract",
        "query": "SELECT strftime ( \"%Y\" , A.order_date ) AS year , SUM ( B.order_quantity * C.product_price ) AS annual_sales_revenue FROM Customer_Orders A JOIN Order_Items B ON A.order_id = B.order_id JOIN Products C ON B.product_id = C.product_id GROUP BY strftime ( \"%Y\" , A.order_date )",
        "englishquestion": "Tell me the year in record and corresponding annual sales revenue.",
        "reasoning_type": "* C",
        "commonsense_knowledge": "Total price is calculated by multiplying unit price to quantity.",
        "english_step": "【step1】: Join the Customer_Orders, Order_Items, and Products tables using order_id and product_id to link relevant data.  【step2】: Calculate the sales revenue for each individual order item by multiplying order_quantity (B) with product_price (C).  【step3】: Group the results by year derived from order_date (A) using YEAR() function, then sum all item revenues per year as annual_sales_revenue.",
        "type": 3,
        "idx": 2263
    },
    {
        "db_id": "contract",
        "query": "SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = \"Apple\" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = \"Apple\" )",
        "englishquestion": "List the highest price, lowest price, and variance of Apple products.",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "The variance is mean squared difference between each data point and the centre of the distribution measured by the mean.",
        "english_step": "【step1】: Calculate the average price (avg_price) and total count (cnt) of Apple products via a subquery.  【step2】: Compute variance for each Apple product using **(product_price - avg_price)² / cnt** by cross-joining with the avg/cnt subquery, then extract max_price and min_price in a separate subquery.  【step3】: Join the variance results (aggregated implicitly) with the max/min prices to output the final columns.",
        "type": 3,
        "idx": 2264
    },
    {
        "db_id": "contract",
        "query": "SELECT max_price , min_price , variance FROM ( SELECT 1.0 * ( product_price - AVG ( product_price ) ) * ( product_price - AVG ( product_price ) ) / COUNT ( * ) AS variance FROM Products WHERE product_name = \"Apple\" ) JOIN ( SELECT MAX ( product_price ) AS max_price , MIN ( product_price ) AS min_price FROM Products WHERE product_name = \"Apple\" )",
        "englishquestion": "Considering only Apple products tell me the highest and lowest prices and also the variance across the Apple range.",
        "reasoning_type": "- * / C",
        "commonsense_knowledge": "The variance is mean squared difference between each data point and the centre of the distribution measured by the mean.",
        "english_step": "【step1】: Calculate the average price of Apple products using window function AVG(product_price) OVER() in subquery t1, filtering by product_name = 'Apple'.  【step2】: Compute price variance using SUM(POW(product_price - avg_price, 2)) / COUNT(*) on t1's results (variance_subquery).  【step3】: Fetch max/min prices via price_subquery and CROSS JOIN with variance_subquery to combine all metrics in final output.",
        "type": 3,
        "idx": 2265
    },
    {
        "db_id": "concert",
        "query": "SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\" ) - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "englishquestion": "List the name and age of each singer at the time of the release of the song \"Gentleman\".",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the song release year of \"Gentleman\" using a subquery: `(SELECT Song_release_year FROM singer WHERE Song_Name = 'Gentleman')`.  【step2】: Calculate the target age by adjusting the singer's current age based on the difference between the song's release year and the current year: `Age + (retrieved_release_year - YEAR(CURDATE()))`.  【step3】: Combine the results by selecting the `Name` and the calculated `target_age` for all singers in the table.",
        "type": 3,
        "idx": 2266
    },
    {
        "db_id": "concert",
        "query": "SELECT Name , Age + ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\" ) - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "englishquestion": "What were the names and ages of all singers of the release of the song \"Gentleman\"",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the song release year of \"Gentleman\" using a subquery: `(SELECT Song_release_year FROM singer WHERE Song_Name = \"Gentleman\")`.  【step2】: Calculate the adjusted age for each singer by adding their current age to the difference between the song's release year and the current year: `Age + (subquery_result) - YEAR(CURDATE())`.  【step3】: Return the names and calculated ages (at the time of the song's release) for all singers in the table, regardless of their association with \"Gentleman\" (no explicit filtering is applied).",
        "type": 3,
        "idx": 2267
    },
    {
        "db_id": "concert",
        "query": "SELECT Name , Age + 2001 - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "englishquestion": "If the song \"Gentleman\" was released in the first year of the 21st century, list the name and age of each singer at the time of the song's release.",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "21st century began on 1 January 2001. Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the current age of each singer from the singer table.  【step2】: Adjust the age by calculating the difference between 2001 (the assumed release year of \"Gentleman\") and the current year, then add this difference to the current age to derive the singer's age at the time of the song's release.  【step3】: Display the singer's name and the calculated target_age.",
        "type": 4,
        "idx": 2268
    },
    {
        "db_id": "concert",
        "query": "SELECT Name , Age + 2001 - strftime ( \"%Y\" , \"now\" ) AS target_age FROM singer",
        "englishquestion": "Assuming that the song \"Gentleman\" was released in the first year of the 21st century, what were the names and ages of all its singers at the time of its release?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "21st century began on 1 January 2001. Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the \"Name\" and current \"Age\" of all singers from the \"singer\" table.  【step2】: Adjust the ages to reflect the year 2001 by calculating the time difference between the current year (via `YEAR(CURRENT_DATE())`) and 2001, then applying this offset to the current age using `Age + 2001 - YEAR(CURRENT_DATE())`, aliased as \"target_age\".  【step3】: Finalize the output to show the singers' names and their calculated ages during the release year of \"Gentleman\".",
        "type": 4,
        "idx": 2269
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , C.Age + ( A.Year - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\"",
        "englishquestion": "What are the names and ages of the participating singers in the concert with the theme of \"Free choice\" at that time?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Filter the 'concert' table to find the concert with the theme \"Free choice\" and retrieve its concert_ID.  【step2】: Join 'singer_in_concert' with the filtered concert results to get the Singer_IDs participating in the concert.  【step3】: Join the 'singer' table to fetch names and calculate adjusted ages (Age + (concert year - current year)) for the singers.",
        "type": 3,
        "idx": 2270
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , C.Age + ( A.Year - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\"",
        "englishquestion": "What were the names and ages of all singers who participated in the \"Free Choice\" themed concert at the time of the concert?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the `concert` (A) and `singer_in_concert` (B) tables using `concert_ID` to identify singers associated with the \"Free choice\" concert.  【step2】: Join the result with the `singer` (C) table via `Singer_ID` to retrieve singer names and current ages.  【step3】: Calculate each singer’s age at the concert by adjusting their current age (`C.Age`) using the difference between the concert year (`A.Year`) and the current year.",
        "type": 3,
        "idx": 2271
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = \"Free choice\" ) - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\" OR strftime ( \"%Y\" , \"now\" ) - C.Age < 1985 GROUP BY C.Name",
        "englishquestion": "If all singers born before 1985 participated in the \"Free Choice\" themed concert, what are the names and ages of the participating singers in the concert with the theme of \"Free choice\" at that time?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the `concert`, `singer_in_concert`, and `singer` tables to link singers with concerts, using `concert_ID` and `Singer_ID` as connection keys.  【step2】: Filter records where the concert theme is \"Free choice\" **OR** the singer’s birth year (derived via `YEAR(CURDATE()) - Age`) is before 1985, introducing a logical inconsistency with the original problem’s requirement.  【step3】: Calculate the singer’s age at the concert using a subquery to fetch the concert year and adjust the age dynamically, then group results by singer name to eliminate duplicates.",
        "type": 4,
        "idx": 2272
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , C.Age + ( ( SELECT Year FROM concert WHERE Theme = \"Free choice\" ) - strftime ( \"%Y\" , \"now\" ) ) AS age_at_concert FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.Theme = \"Free choice\" OR strftime ( \"%Y\" , \"now\" ) - C.Age < 1985 GROUP BY C.Name",
        "englishquestion": "Assuming that all the singers born before 1985 participated in the \"Free Choice\" themed concert, what were the names and ages of all the singers who took part at the time of the concert?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the concert year for the 'Free choice' theme using a subquery, then calculate each singer's birth year by subtracting their current age from the current year.  【step2】: Join singer, singer_in_concert, and concert tables to link singers with the concert, applying the condition that either the theme matches 'Free choice' or the calculated birth year is before 1985.  【step3】: Compute the age at the concert by adding the difference between the concert year and the current year to the singer's current age, then group results by name to eliminate duplicates.",
        "type": 4,
        "idx": 2273
    },
    {
        "db_id": "concert",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM concert",
        "englishquestion": "How many years has it been since the earliest concert?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Retrieve the earliest concert year using MIN(Year) from the concert table.  【step2】: Calculate the current year using YEAR(NOW()).  【step3】: Subtract the earliest year from the current year and alias the result as \"years\".",
        "type": 3,
        "idx": 2274
    },
    {
        "db_id": "concert",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM concert",
        "englishquestion": "How many years ago did the first concert occur?",
        "reasoning_type": "- C",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Retrieve the current year using YEAR(NOW()).  【step2】: Determine the earliest year from the \"Year\" column in the \"concert\" table using MIN(Year).  【step3】: Calculate the difference between the current year and the earliest year, and alias the result as \"years\".",
        "type": 3,
        "idx": 2275
    },
    {
        "db_id": "concert",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = \"Wide Awake\" UNION ALL SELECT Year FROM concert WHERE Theme != \"Wide Awake\" )",
        "englishquestion": "If the \"Wide Awake\" themed concert was held three years earlier, how many years has it been since the earliest concert?",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】Adjust the year of the \"Wide Awake\" concert by subtracting 3, creating a temporary column Year.  【step2】Combine the adjusted year with non-\"Wide Awake\" concert years using UNION ALL in a subquery.  【step3】Calculate the difference between the current year and the earliest year (MIN(Year)) from the combined results.",
        "type": 4,
        "idx": 2276
    },
    {
        "db_id": "concert",
        "query": "SELECT strftime ( \"%Y\" , \"now\" ) - MIN ( Year ) AS years FROM ( SELECt Year - 3 AS Year FROM concert WHERE Theme = \"Wide Awake\" UNION ALL SELECT Year FROM concert WHERE Theme != \"Wide Awake\" )",
        "englishquestion": "How many years ago did the earliest concert occur if the concert with the theme \"Wide Awake\" took place three years earlier?",
        "reasoning_type": "- C H",
        "commonsense_knowledge": "The time duration is calculated by substracting the start time from the end time.",
        "english_step": "【step1】: Adjust the year for concerts with the theme \"Wide Awake\" by subtracting 3 years.  【step2】: Combine this adjusted dataset with unmodified years from other concerts using UNION ALL.  【step3】: Calculate the difference between the current year and the minimum year in the merged dataset to determine how many years ago the earliest concert occurred.",
        "type": 4,
        "idx": 2277
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , A.Year - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\"",
        "englishquestion": "What are the names of the singer participating in the \"Home Visits\" concert, and how old will they be on its 20th anniversary?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join concert, singer_in_concert, and singer tables to link singer details with the \"Home Visits\" concert.  【step2】: Filter the joined data to retain only records where the concert name is \"Home Visits\".  【step3】: Calculate each singer's age on the 20th anniversary by adding their current age to the time difference between the concert year and the target anniversary year (current age + (concert year + 20 - current year)).",
        "type": 3,
        "idx": 2278
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , A.Year - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\"",
        "englishquestion": "What are the names of the \"Home Visits\" concert singer, and how old will they be on its 20th anniversary?",
        "reasoning_type": "- + C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the `concert` table with `singer_in_concert` using `concert_ID` to map the concert to participating singers.  【step2】: Join the result with the `singer` table using `Singer_ID` to retrieve singer names and ages.  【step3】: Filter records where `concert_Name` is \"Home Visits\" and calculate the target age by adjusting the singer’s current age with the 20-year difference between the concert’s year and its 20th anniversary.",
        "type": 3,
        "idx": 2279
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = \"Home Visits\" ) - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = \"Stark's Park\" ) GROUP BY B.Singer_ID",
        "englishquestion": "If all the singers who participated in concerts held in Stark Park also participated in the \"Home Visits\" concert, what are the names of the singer participating in the \"Home Visits\" concert, and how old will they be on its 20th anniversary?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve all Singer_IDs who performed in concerts held at 'Stark''s Park' by joining concert, stadium, and singer_in_concert tables.  【step2】: Combine singers from 'Home Visits' concert and the Singer_IDs from Step 1 via an OR condition, then deduplicate using GROUP BY.  【step3】: Calculate the target_age for each singer by extracting the year of the 'Home Visits' concert and adjusting for the 20th anniversary offset.",
        "type": 4,
        "idx": 2280
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name , ( SELECT Year FROM concert WHERE concert_Name = \"Home Visits\" ) - strftime ( \"%Y\" , \"now\" ) + C.Age + 20 AS target_age FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID WHERE A.concert_Name = \"Home Visits\" OR B.Singer_ID IN ( SELECT C.Singer_ID FROM concert A JOIN stadium B ON A.Stadium_ID = B.Stadium_ID JOIN singer_in_concert C ON A.concert_ID = C.concert_ID WHERE B.Name = \"Stark's Park\" ) GROUP BY B.Singer_ID",
        "englishquestion": "What will be the ages and names of the \"Home Visits\" concert singers on its 20th anniversary, if all the singers who performed at concerts in Stark Park also took part in it?",
        "reasoning_type": "- + C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join the concert, singer_in_concert, and singer tables to retrieve singers associated with the \"Home Visits\" concert or those who performed at Stark's Park.  【step2】: Calculate the target age using the formula: `(Home Visits concert year - current year + singer's current age + 20)`, and filter singers via a subquery checking Stark's Park participation.  【step3】: Group results by Singer_ID to eliminate duplicates, ensuring each singer appears once with their name and calculated age.",
        "type": 4,
        "idx": 2281
    },
    {
        "db_id": "concert",
        "query": "SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = \"Hampden Park\" ) AS total FROM stadium WHERE Name = \"Balmoor\"",
        "englishquestion": "When all tickets sold out, how much money can be made from ticket sales at the Balmoor stadium with a ticket price of 20 dollars and the Hampden Park stadium with a ticket price of 5.5 dollars?",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity to unit price.",
        "english_step": "【step1】: Retrieve the capacity of 'Balmoor' stadium and calculate its total revenue by multiplying capacity with $20.  【step2】: Execute a subquery to fetch the capacity of 'Hampden Park' stadium and compute its total revenue using $5.5 per ticket.  【step3】: Sum the revenue from both stadiums and output the combined total under the alias \"total\".",
        "type": 3,
        "idx": 2282
    },
    {
        "db_id": "concert",
        "query": "SELECT Capacity * 20 + ( SELECT Capacity * 5.5 FROM stadium WHERE Name = \"Hampden Park\" ) AS total FROM stadium WHERE Name = \"Balmoor\"",
        "englishquestion": "If the ticket price for Balmoor stadium is $20 and for Hampden Park stadium is $5.5, and all tickets are sold out, how much money can be generated from ticket sales?",
        "reasoning_type": "+ * C",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity to unit price.",
        "english_step": "【step1】: Calculate ticket sales for 'Balmoor' stadium by multiplying its capacity by $20.  【step2】: Calculate ticket sales for 'Hampden Park' stadium via a subquery, multiplying its capacity by $5.5.  【step3】: Combine the two results using the `+` operator to produce the total revenue from both stadiums.",
        "type": 3,
        "idx": 2283
    },
    {
        "db_id": "concert",
        "query": "SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = \"Balmoor\"",
        "englishquestion": "If the capacity of the Hampden Park stadium is twice that of the Balmoor stadium, when all tickets sold out, how much money can be made from ticket sales at the Balmoor stadium with a ticket price of 20 dollars and the Hampden Park stadium with a ticket price of 5.5 dollars?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity to unit price.",
        "english_step": "【step1】: Retrieve the capacity of Balmoor stadium from the database table using the WHERE clause to filter by Name = 'Balmoor'.  【step2】: Calculate Balmoor's ticket revenue by multiplying its capacity by $20, and compute Hampden Park's revenue using twice Balmoor's capacity (as per the capacity relationship) multiplied by $5.5.  【step3】: Sum the calculated revenues from both stadiums and output the total using the arithmetic expression in the SELECT statement.",
        "type": 4,
        "idx": 2284
    },
    {
        "db_id": "concert",
        "query": "SELECT Capacity * 20 + 2 * Capacity * 5.5 AS total FROM stadium WHERE Name = \"Balmoor\"",
        "englishquestion": "Assuming the ticket price for Balmoor stadium is $20 and for Hampden Park stadium is $5.5, and if the Hampden Park stadium has twice the capacity of the Balmoor stadium, what would be the total revenue generated from ticket sales if all tickets are sold out at both stadiums?",
        "reasoning_type": "+ * C H",
        "commonsense_knowledge": "Total price is calculated by multiplying quantity to unit price.",
        "english_step": "【step1】: Retrieve the capacity of Balmoor stadium from the 'stadium' table.  【step2】: Calculate Balmoor's revenue by multiplying its capacity by $20.  【step3】: Calculate Hampden Park's revenue (using twice Balmoor's capacity multiplied by $5.5) and sum both revenues to get the total.",
        "type": 4,
        "idx": 2285
    },
    {
        "db_id": "concert",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age >= 1980 )",
        "englishquestion": "Singers born before 1980 earn $355 per concert, while singers born after 1980 earn $228 per concert. How much was spent on paying the singers for the concerts held in Somerset Park stadium?",
        "reasoning_type": "- + * C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the total payment for singers born before 1980 by joining the concert, singer_in_concert, singer, and stadium tables, filtering for 'Somerset Park' stadium and checking if YEAR(CURDATE()) - Age < 1980. Multiply the count of qualifying records by $355.  【step2】: Calculate the total payment for singers born in or after 1980 using the same table joins and stadium filter, but with YEAR(CURDATE()) - Age >= 1980. Multiply the count by $228.  【step3】: Combine the results of the two subqueries via a CROSS JOIN and sum the two calculated values (p1 + p2) to produce the final total cost.",
        "type": 3,
        "idx": 2286
    },
    {
        "db_id": "concert",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND strftime ( \"%Y\" , \"now\" ) - C.Age >= 1980 )",
        "englishquestion": "What was the total expenditure on paying singers for concerts held at Somerset Park stadium, given that singers born before 1980 earned $355 per concert and those born after 1980 earned $228 per concert?",
        "reasoning_type": "- + * C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Join tables concert, singer_in_concert, singer, and stadium to filter concerts held at \"Somerset Park\".  【step2】: Calculate costs separately for singers born before 1980 (355 * count) and after 1980 (228 * count) using YEAR(NOW()) - Age to derive birth year.  【step3】: Combine the two calculated costs via CROSS JOIN and sum them to get the total expenditure.",
        "type": 3,
        "idx": 2287
    },
    {
        "db_id": "concert",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year >= 1980 )",
        "englishquestion": "Singers born before 1980 earn $355 per concert, while singers born after 1980 earn $228 per concert. If Justin Brown is 3 years older than John Nizinik, how much was spent on paying the singers for the concerts held in Somerset Park stadium?",
        "reasoning_type": "- + * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate birth years for all singers. Handle Justin Brown's special case by deriving his birth year based on John Nizinik's age (John's birth year = current year - John's age, Justin's birth year = John's birth year - 3). Use UNION ALL to combine regular singers and Justin's adjusted data.  【step2】: Compute payment for pre-1980 singers (p1) by joining concert/stadium data, filtering to \"Somerset Park\" stadium, counting eligible concert appearances, and multiplying by $355.  【step3】: Repeat calculation for post-1980 singers (p2) with $228 rate. Sum p1 and p2 in the final SELECT to get total cost.",
        "type": 4,
        "idx": 2288
    },
    {
        "db_id": "concert",
        "query": "SELECT p1 + p2 AS cost FROM ( SELECT 355 * ( COUNT ( * ) ) AS p1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year < 1980 ) JOIN ( SELECT 228 * ( COUNT ( * ) ) AS p2 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN ( SELECT Singer_ID , Name , strftime ( \"%Y\" , \"now\" ) - Age AS birth_year FROM singer WHERE Name != \"Justin Brown\" UNION ALL SELECT Singer_ID , Name , ( SELECT strftime ( \"%Y\" , \"now\" ) - Age FROM singer WHERE Name = \"John Nizinik\" ) - 3 AS birth_year FROM singer WHERE Name = \"Justin Brown\" ) C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON A.Stadium_ID = D.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.birth_year >= 1980 )",
        "englishquestion": "If Justin Brown was 3 years older than John Nizinik, what was the total expenditure on paying singers for concerts held at Somerset Park stadium, given that singers born before 1980 earned $355 per concert and those born after 1980 earned $228 per concert?",
        "reasoning_type": "- + * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Calculate adjusted birth years for singers. For all singers except Justin Brown, use current year minus age. For Justin Brown, derive birth year by subtracting 3 from John Nizinik's calculated birth year (YEAR(CURDATE()) - John's Age - 3).  【step2】: Calculate pre-1980 costs ($355/concert). Count eligible singers (birth_year < 1980) linked to Somerset Park concerts, multiply by 355. Simultaneously calculate post-1980 costs ($228/concert) using same linkage but birth_year >= 1980.  【step3】: Combine both cost components (pre-1980 total + post-1980 total) through JOIN operations between the two subqueries to output final expenditure.",
        "type": 4,
        "idx": 2289
    },
    {
        "db_id": "concert",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "englishquestion": "Which stadiums have the lowest and highest average attendance rates respectively, and how many concerts have they each held?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Retrieve the stadium name with the highest average attendance rate by calculating `100.0 * Average / Capacity`, sorting in descending order, and limiting to 1 result.  【step2】: Retrieve the stadium name with the lowest average attendance rate using the same formula but sorting in ascending order, and count concerts for both stadiums by matching their IDs via nested subqueries.  【step3】: Combine the highest/lowest stadium names and their corresponding concert counts using `CROSS JOIN` to merge all subquery results into a single output.",
        "type": 3,
        "idx": 2290
    },
    {
        "db_id": "concert",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM stadium GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "englishquestion": "What are the names of the stadiums with the highest and lowest average attendance rates, and how many concerts have been held in each of them?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Extract the stadium name with the highest average attendance rate by grouping and sorting stadiums in descending order of (Average/Capacity)*100.  【step2】: Calculate the concert count for the highest-attendance stadium by joining with the concert table using its Stadium_ID obtained via a nested subquery.  【step3】: Repeat steps 1-2 for the lowest-attendance stadium, then combine all results using CROSS JOIN to display all values in a single row.",
        "type": 3,
        "idx": 2291
    },
    {
        "db_id": "concert",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "englishquestion": "Suppose Gayfield Park stadium had a tenth of the capacity of Hampden Park stadium, which stadiums have the lowest and highest average attendance rates respectively, and how many concerts have they each held?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Create a modified dataset by adjusting Gayfield Park's capacity (set to 1/10 of Hampden Park's capacity) via subquery and UNION ALL with other stadiums' original data.  【step2】: Calculate attendance rates (Average/Capacity) to determine the highest (DESC LIMIT 1) and lowest (ASC LIMIT 1) stadiums from the modified dataset.  【step3】: Count concerts for the identified highest/lowest stadiums by joining the `stadium` and `concert` tables, using nested subqueries to re-fetch their Stadium_IDs.",
        "type": 4,
        "idx": 2292
    },
    {
        "db_id": "concert",
        "query": "SELECT * FROM ( SELECT Name AS highest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_highest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity DESC LIMIT 1 ) ) JOIN ( SELECT Name AS lowest_name FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) JOIN ( SELECT COUNT ( * ) AS concerts_in_lowest_stadium FROM stadium A JOIN concert B ON A.Stadium_ID = B.Stadium_ID WHERE A.Stadium_ID = ( SELECT Stadium_ID FROM ( SELECT Stadium_ID , Name , ( SELECT Capacity FROM stadium WHERE Name = \"Hampden Park\" ) / 10 AS Capacity , Average FROM stadium WHERE Name = \"Gayfield Park\" UNION ALL SELECt Stadium_ID , Name , Capacity , Average FROM stadium WHERE Name != \"Gayfield Park\" ) GROUP BY Stadium_ID ORDER BY 100.0 * Average / Capacity ASC LIMIT 1 ) )",
        "englishquestion": "What are the names of the stadiums with the highest and lowest average attendance rates, if Gayfield Park stadium has one-tenth the capacity of Hampden Park stadium, and how many concerts have been held in each of them?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Adjust Gayfield Park's capacity to 1/10 of Hampden Park's and create a unified dataset with all stadiums.  【step2】: Calculate attendance rate (Average/Capacity*100) for each stadium, then select the stadium with the highest rate (DESC LIMIT 1) and the lowest rate (ASC LIMIT 1).  【step3】: Count concerts for both selected stadiums by joining the concert table and filtering with their Stadium_IDs from Step 2.",
        "type": 4,
        "idx": 2293
    },
    {
        "db_id": "concert",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "englishquestion": "What are the ID and name of each concert held at Somerset Park stadium, and what percentage of the singers in each of these concert are female singers?",
        "reasoning_type": "+ * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total number of singers (n) per concert at Somerset Park stadium by joining concert, singer_in_concert, singer, and stadium tables, filtered by stadium name and grouped by concert_ID/Name.  【step2】: Calculate female singer counts (n_female) via two subqueries combined with UNION ALL: one counts actual female singers per concert, the other ensures concerts with zero females are included by using NOT IN and explicitly setting n_female=0.  【step3】: Join the results from Step1 (total singers) and Step2 (female counts) on concert_ID, then compute the female_proportion as (n_female / n) * 100.0 for each concert.",
        "type": 2,
        "idx": 2294
    },
    {
        "db_id": "concert",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE D.Name = \"Somerset Park\" GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "englishquestion": "What are the ID and name of each concert held at Somerset Park stadium, and what is the percentage of female singers in each of these concert held at Somerset Park?",
        "reasoning_type": "+ * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of female singers (n_female) for each Somerset Park concert. If no female singers exist, explicitly set n_female=0 using UNION ALL to ensure concert entries aren't excluded.  【step2】: Calculate the total number of singers (n) for each Somerset Park concert by joining concert, singer_in_concert, singer, and stadium tables with Name='Somerset Park'.  【step3】: Join the results of step1 (t1) and step2 (t2) on concert_ID, then compute female_proportion via (n_female/n)*100 to finalize the percentage output.",
        "type": 2,
        "idx": 2295
    },
    {
        "db_id": "concert",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "englishquestion": "If the \"Week 2\" concert was held at Somerset Park stadium, what are the ID and name of each concert held at Somerset Park stadium, and what percentage of the singers in each concert held at Somerset Park stadium are female singers?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve concerts held at Somerset Park stadium (including \"Week 2\") and count female singers per concert, handling cases with no female singers via UNION ALL.  【step2】: Calculate total number of singers per concert for the same stadium/criteria.  【step3】: Combine step1 and step2 results via concert_ID, compute female percentage as (n_female/n)*100.0.",
        "type": 4,
        "idx": 2296
    },
    {
        "db_id": "concert",
        "query": "SELECT t1.concert_ID, t1.concert_Name, 100.0 * n_female / n AS female_proportion FROM (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID UNION ALL SELECT A.concert_ID, A.concert_Name, 0 AS n_female FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND A.concert_ID NOT IN (SELECT A.concert_ID FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") AND C.Is_male = \"F\" GROUP BY A.concert_ID) GROUP BY A.concert_ID) t1 JOIN (SELECT A.concert_ID, A.concert_Name, COUNT (*) AS n FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN singer C ON B.Singer_ID = C.Singer_ID JOIN stadium D ON D.Stadium_ID = A.Stadium_ID WHERE (D.Name = \"Somerset Park\" OR A.concert_Name = \"Week 2\") GROUP BY A.concert_ID) t2 ON t1.concert_ID = t2.concert_ID",
        "englishquestion": "What are the ID and name of each concert held at Somerset Park stadium, and what is the percentage of female singers in each concert held at Somerset Park, if the \"Week 2\" concert was held there?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Extract female singer counts for concerts at Somerset Park or named 'Week 2' using two subqueries: one counting actual female singers (WHERE C.Is_male='F'), another assigning 0 via NOT IN exclusion for concerts with no female singers. Combine results with UNION ALL into temporary table t1.  【step2】: Calculate total singer counts (n) per concert in the same venue/name conditions via subquery t2, joining concert, singer_in_concert, singer, and stadium tables.  【step3】: Join t1 and t2 on concert_ID to compute female_proportion as (n_female / n) * 100.0, ensuring all qualifying concerts (including those with 0 females) are included.",
        "type": 4,
        "idx": 2297
    },
    {
        "db_id": "concert",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "englishquestion": "What percentage of the concerts were held in the top three stadiums in terms of average attendance rate?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Identify the top three stadiums based on average attendance rate (calculated as (100.0 * Average) / Capacity) using a subquery with ORDER BY and LIMIT 3.  【step2】: Count the total number of concerts held in these top three stadiums by filtering the concert table with WHERE Stadium_ID IN (subquery result).  【step3】: Calculate the percentage by dividing the count from step 2 by the total number of concerts (via a subquery SELECT COUNT(*) FROM concert) and multiplying by 100.0.",
        "type": 3,
        "idx": 2298
    },
    {
        "db_id": "concert",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM concert WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "englishquestion": "What is the percentage of concerts that took place in the three stadiums with the highest average attendance rates?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Retrieve the Stadium_IDs of the three stadiums with the highest average attendance rates (calculated as 100.0 * Average / Capacity) from the stadium table, ordered descendingly and limited to 3.  【step2】: Count the number of concerts (COUNT(*)) in the concert table where Stadium_ID matches the three IDs obtained in Step 1.  【step3】: Calculate the percentage by dividing the count from Step 2 by the total number of concerts (subquery: SELECT COUNT(*) FROM concert), then multiply by 100.0.",
        "type": 3,
        "idx": 2299
    },
    {
        "db_id": "concert",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = \"Glebe Park\" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != \"Bleeding Love\" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "englishquestion": "If the \"Bleeding Love\" themed concert was held at Glebe Park stadium, what percentage of the concerts were held in the top three stadiums in terms of average attendance rate?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Identify the top three stadiums based on average attendance rate by calculating (Average / Capacity * 100) for each stadium, sorting in descending order, and limiting to 3 results.  【step2】: Combine two sets of Stadium_IDs: ① the specific \"Glebe Park\" stadium and ② all concerts with themes other than \"Bleeding Love\".  【step3】: Calculate the percentage by counting how many combined Stadium_IDs fall within the top three stadiums, then dividing by the total number of concerts and multiplying by 100.0.",
        "type": 4,
        "idx": 2300
    },
    {
        "db_id": "concert",
        "query": "SELECT 100.0 * COUNT ( * ) / ( SELECT COUNT ( * ) FROM concert ) AS percent FROM ( SELECT Stadium_ID FROM stadium WHERE Name = \"Glebe Park\" UNION ALL SELECT Stadium_ID FROM concert WHERE Theme != \"Bleeding Love\" ) WHERE Stadium_ID IN ( SELECT Stadium_ID FROM stadium ORDER BY 100.0 * Average / Capacity DESC LIMIT 3 )",
        "englishquestion": "What percentage of concerts took place in the three stadiums with the highest average attendance rates, assuming that the concert with the theme \"Bleeding Love\" took place at the Glebe Park stadium?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Identify the top 3 stadiums by average attendance rate (calculated as \\( \\frac{100.0 \\times \\text{Average}}{\\text{Capacity}} \\)) and retrieve their `Stadium_ID`.  【step2】: Create a derived table combining:  - The `Stadium_ID` of \"Glebe Park\" (regardless of concert theme).  - All concerts with themes other than \"Bleeding Love\" (to align with the assumption that \"Bleeding Love\" only occurs at \"Glebe Park\").  【step3】: Calculate the percentage of concerts in the derived table that occurred in the top 3 stadiums by dividing the matching count by the total concert count and multiplying by 100.0.",
        "type": 4,
        "idx": 2301
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "englishquestion": "Which stadium has at least three times the number of singers who have sung at the Glebe Park stadium?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of distinct singers who performed at the 'Glebe Park' stadium using a subquery: `SELECT COUNT(DISTINCT B.Singer_ID) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = 'Glebe Park'`.  【step2】: Group concerts by stadium and count distinct singers per stadium via `JOIN` operations across the concert, singer_in_concert, and stadium tables.  【step3】: Filter grouped results using `HAVING` to retain only stadiums with singer counts ≥ 3× the subquery result from Step 1.",
        "type": 2,
        "idx": 2302
    },
    {
        "db_id": "concert",
        "query": "SELECT C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID GROUP BY C.Stadium_ID HAVING COUNT ( DISTINCT ( B.Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "englishquestion": "Which stadium has had a minimum of three times more singers than Glebe Park does?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve the number of distinct singers at Glebe Park by joining the `concert`, `singer_in_concert`, and `stadium` tables, filtering for stadium name 'Glebe Park'.  【step2】: Calculate the total distinct singers per stadium by joining the same tables and grouping by `Stadium_ID`.  【step3】: Filter stadiums where the singer count is at least three times the value obtained in Step 1 using the `HAVING` clause with a correlated subquery.",
        "type": 2,
        "idx": 2303
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = \"Balmoor\" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Somerset Park\" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "englishquestion": "If all the singers who have performed at Somerset Park stadium also performed at Balmoor stadium, what is the name of the stadium with at least three times the number of singers who have sung at the Glebe Park stadium?",
        "reasoning_type": "* H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Combine all singers from concerts along with their stadium info, and forcibly include singers from \"Somerset Park\" as if they performed at \"Balmoor\" stadium using UNION ALL.  【step2】: Group the combined results by Stadium_ID, count distinct singers per stadium.  【step3】: Filter stadiums where the singer count is ≥3 times the count from \"Glebe Park\", calculated via a nested subquery on its distinct singers.",
        "type": 4,
        "idx": 2304
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM ( SELECT C.Stadium_ID , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID UNION ALL SELECT ( SELECT Stadium_ID FROM stadium WHERE Name = \"Balmoor\" ) , B.Singer_ID , C.Name FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Somerset Park\" ) GROUP BY Stadium_ID HAVING COUNT ( DISTINCT ( Singer_ID ) ) >= 3 * ( SELECT COUNT ( DISTINCT ( B.Singer_ID ) ) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID JOIN stadium C ON A.Stadium_ID = C.Stadium_ID WHERE C.name = \"Glebe Park\" )",
        "englishquestion": "What is the name of the stadium that has a minimum of three times more singers than Glebe Park if the singers who have performed at Somerset Park also performed at the Balmoor stadium?",
        "reasoning_type": "* H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Collect all singer performances from regular concerts and duplicate Somerset Park performances under Balmoor's Stadium_ID by using UNION ALL. This ensures singers who performed at Somerset Park are artificially linked to Balmoor.  【step2】: Group the combined data by Stadium_ID, count distinct singers for each stadium, and calculate Glebe Park's distinct singer count multiplied by 3.  【step3】: Filter stadiums where their singer count meets or exceeds 3× Glebe Park's count using HAVING clause, then return the qualifying stadium names.",
        "type": 4,
        "idx": 2305
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = \"Balmoor\" )",
        "englishquestion": "What is the name of the stadium that has a highest attendance rate more than twice the highest attendance rate of the Balmoor stadium?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Calculate the attendance rate percentage (100.0 * Highest / Capacity) for the Balmoor stadium.  【step2】: Multiply Balmoor's attendance rate by 2 to establish the threshold.  【step3】: Filter stadiums where their attendance rate exceeds this threshold and return their names.",
        "type": 3,
        "idx": 2306
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / Capacity FROM stadium WHERE Name = \"Balmoor\" )",
        "englishquestion": "Which stadium's maximum attendance rate is more than double the Balmoor stadium's highest attendance rate? Give the the stadium names.",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Calculate Balmoor's attendance rate: (100.0 * Highest / Capacity)  【step2】: Multiply Balmoor's rate by 2 to get the threshold.  【step3】: Compare each stadium's attendance rate against the threshold and return qualifying names.",
        "type": 3,
        "idx": 2307
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = \"Balmoor\" )",
        "englishquestion": "If the capacity of the Balmoor stadium is 5600, what is the name of the stadium that has a highest attendance rate more than twice the highest attendance rate of the Balmoor stadium?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Calculate Balmoor's highest attendance rate using the subquery: `100.0 * Highest / 5600` where Name is 'Balmoor'.  【step2】: Double the result from Step 1 to determine the threshold attendance rate (`2 * subquery_result`).  【step3】: Select stadium names where the calculated attendance rate (`100.0 * Highest / Capacity`) exceeds the threshold from Step 2.",
        "type": 4,
        "idx": 2308
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM stadium WHERE 100.0 * Highest / Capacity > 2 * ( SELECT 100.0 * Highest / 5600 FROM stadium WHERE Name = \"Balmoor\" )",
        "englishquestion": "Which stadium's maximum attendance rate is more than double the Balmoor stadium's highest attendance rate, given its capacity of 5600? List the stadium names.",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "Attendance rate is calculated by divding attendance amount by the capacity of the stadium.",
        "english_step": "【step1】: Calculate Balmoor stadium's highest attendance rate by dividing its \"Highest\" attendance value by its capacity (5600) and multiplying by 100.  【step2】: Multiply Balmoor's attendance rate by 2 to create the threshold.  【step3】: Compare every stadium's attendance rate (100.0 * Highest / Capacity) against this threshold and return qualifying names.",
        "type": 4,
        "idx": 2309
    },
    {
        "db_id": "concert",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" )",
        "englishquestion": "What are the IDs and names of the concerts held after 2012 and has more singers than the \"Happy Tonight\" themed concert, and how many times is it?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter concerts held after 2012 and join with singer records.  【step2】: Calculate the number of singers in the \"Happy Tonight\" concert via subquery as the comparison baseline.  【step3】: Group filtered concerts, apply HAVING clause to keep those with more singers than the baseline, and compute the ratio using the baseline subquery.",
        "type": 2,
        "idx": 2310
    },
    {
        "db_id": "concert",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * COUNT (DISTINCT (B.Singer_ID)) / (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 GROUP BY A.concert_ID HAVING COUNT (DISTINCT (B.Singer_ID)) > (SELECT COUNT (DISTINCT (B.Singer_ID)) FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" )",
        "englishquestion": "What are the ID and name of the post-2012 concert features more singers than the \"Happy Tonight\" themed concert, what is the ratio of the number of singers in both concerts?",
        "reasoning_type": "* /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter concerts after 2012 and join with singers. The base dataset is formed by combining `concert` (aliased as A) and `singer_in_concert` (aliased as B) tables via `concert_ID`, with `A.Year > 2012` as the initial filter.  【step2】: Group by concert ID/name, calculate singer counts. For each qualifying concert, count distinct singers. Use a correlated subquery in HAVING to enforce that this count exceeds the singer count of the \"Happy Tonight\" concert (subquery reuses same join logic but filters by theme).  【step3】: Compute the ratio. Add a scalar subquery in the SELECT clause to calculate the \"Happy Tonight\" singer count once, then divide the current concert's singer count by this value (cast to float via 1.0*) to derive the `times` ratio.",
        "type": 2,
        "idx": 2311
    },
    {
        "db_id": "concert",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) )",
        "englishquestion": "If singer Joe Sharp performed in every concert, what are the IDs and names of concerts held after 2012 has more singers than the \"Happy Tonight\" themed concert, and and how many times is it?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter concerts held after 2012 and exclude Joe Sharp's records, joining concert and singer_in_concert tables. Group by concert_ID and concert_Name to count distinct singers (excluding Joe).  【step2】: Calculate the baseline singer count plus 1 (excluding Joe) for the \"Happy Tonight\" concert via a subquery, used as the denominator for comparison.  【step3】: Compare each concert's adjusted singer count (COUNT + 1) against the baseline in HAVING, then compute the ratio (current count +1)/(baseline count +1) as times in SELECT.",
        "type": 4,
        "idx": 2312
    },
    {
        "db_id": "concert",
        "query": "SELECT A.concert_ID, A.concert_Name, 1.0 * (COUNT (DISTINCT (B.Singer_ID)) + 1) / (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) ) AS times FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Year > 2012 AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) GROUP BY A.concert_ID HAVING (COUNT (DISTINCT (B.Singer_ID)) + 1) > (SELECT COUNT (DISTINCT (B.Singer_ID)) + 1 FROM concert A JOIN singer_in_concert B ON A.concert_ID = B.concert_ID WHERE A.Theme = \"Happy Tonight\" AND B.Singer_ID != (SELECT Singer_ID FROM singer WHERE Name = \"Joe Sharp\" ) )",
        "englishquestion": "Assuming that Joe Sharp performed in all concerts, what are the ID and name of post-2012 concert features more singers than the \"Happy Tonight\" themed concert, and what is the ratio of the number of singers in both concerts?",
        "reasoning_type": "+ * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter concerts after 2012, exclude Joe Sharp's participation record, and join with singer_in_concert to get singer data. Use subqueries to:  1. Find Joe Sharp's Singer_ID  2. Exclude him via B.Singer_ID != (subquery)  3. Apply A.Year > 2012 condition.  【step2】: Group by concert_ID and calculate singer count (plus 1 for Joe's assumed participation). Use HAVING to compare against the \"Happy Tonight\" concert's singer count (similarly calculated via subquery that excludes Joe).  【step3】: Compute the ratio 1.0*(current_concert_singer_count+1)/(Happy_Tonight_singer_count+1) via scalar subquery in the SELECT clause, ensuring consistent exclusion of Joe Sharp in both numerator and denominator calculations.",
        "type": 4,
        "idx": 2313
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Love\" ) - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - Song_release_year ) FROM singer WHERE Song_Name = \"Love\" )",
        "englishquestion": "At the time of the release of the song \"Love,\" what are the names of singers who were more than twice as old as the singer of the song?",
        "reasoning_type": "- * C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Determine the release year of the song \"Love\" and calculate the age of its singer at that time using subqueries.  【step2】: Compute each singer's age during the release year of \"Love\" by subtracting their birth year (derived from current year minus age) from the song's release year.  【step3】: Filter singers where their computed age during the release year is more than twice the original singer's age at that time.",
        "type": 3,
        "idx": 2314
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM singer WHERE ( SELECT Song_release_year FROM singer WHERE Song_Name = \"Love\" ) - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - Song_release_year ) FROM singer WHERE Song_Name = \"Love\" )",
        "englishquestion": "Which singers, at the time when \"Love\" was released, had an age more than double that of the singer who performed the song? List their names.",
        "reasoning_type": "- * C",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the release year of the song \"Love\" and calculate the age of its performer **at the time of release** using subqueries: `(Song_release_year - (YEAR(CURDATE()) - Age))`.  【step2】: Calculate each singer's age **at the time of \"Love\" release** by comparing their birth year (`YEAR(CURDATE()) - Age`) to the song’s release year.  【step3】: Filter singers whose calculated age (from step 2) exceeds double the performer’s age (from step 1) using the inequality in the `WHERE` clause.",
        "type": 3,
        "idx": 2315
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM singer WHERE 2010 - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - 2010 ) FROM singer WHERE Song_Name = \"Love\" )",
        "englishquestion": "If \"Love\" was released in 2010, at the time of the release of the song \"Love,\" what are the names of singers who were more than twice as old as the singer of the song?",
        "reasoning_type": "- * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Retrieve the singer's age of the song \"Love\" at the time of its 2010 release using the subquery: `Age - (YEAR(CURDATE()) - 2010)` to adjust their current age to their age in 2010.  【step2】: Calculate each singer's age in 2010 via `2010 - (YEAR(CURDATE()) - Age)`, which derives their birth year from the current age and subtracts it from 2010.  【step3】: Filter singers whose 2010 age (step2) exceeds twice the \"Love\" singer's 2010 age (step1) using the condition `> 2 * (subquery)`.",
        "type": 4,
        "idx": 2316
    },
    {
        "db_id": "concert",
        "query": "SELECT Name FROM singer WHERE 2010 - ( strftime ( \"%Y\" , \"now\" ) - Age ) > 2 * ( SELECT Age - ( strftime ( \"%Y\" , \"now\" ) - 2010 ) FROM singer WHERE Song_Name = \"Love\" )",
        "englishquestion": "Assuming \"Love\" was released in 2010, which singers, at that time, had an age that was more than twice the age of the singer who performed the song? List their names.",
        "reasoning_type": "- * C H",
        "commonsense_knowledge": "Age is calculated by substracting date of birth from a given date.",
        "english_step": "【step1】: Extract the base age of the singer who performed \"Love\" in 2010 using a subquery: Calculate their age at that time by adjusting their current age with the difference between the current year and 2010.  【step2】: Compute each singer's birth year by subtracting their current age from the current year, then derive their age in 2010 as `2010 - (birth year)`.  【step3】: Filter singers whose 2010 age (from Step 2) exceeds twice the base age (from Step 1) and return their names.",
        "type": 4,
        "idx": 2317
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "englishquestion": "Which continent is the country with the highest GNP per capita located in?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Calculate the per capita GNP for each country by dividing GNP by Population (using 1.0 to ensure floating-point division).  【step2】: Sort all countries in descending order based on the calculated per capita GNP.  【step3】: Select the Continent value from the top-ranked row (highest per capita GNP) using LIMIT 1.",
        "type": 3,
        "idx": 2318
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "englishquestion": "In which continent can we find the country with the highest GNP per capita?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Calculate the GNP per capita (GNP / Population) for each country.  【step2】: Order the results in descending order based on the calculated GNP per capita.  【step3】: Select the continent of the top-ranked country using LIMIT 1.",
        "type": 3,
        "idx": 2319
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM (SELECT \"1982268.0\" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "englishquestion": "If the gross national product of the country where Korla City is located is 1982268.0, which continent is the country with the highest GNP per capita located in?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Locate the country containing Korla City by joining the country and city tables, retrieving the country's name.  【step2】: Create a combined dataset via UNION ALL: one subset forces GNP=1982268.0 for Korla's country (using CAST), while the other retains original GNP values for all other countries, both including Population and Continent.  【step3】: Calculate GNP per capita (GNP/Population) for all entries in the combined dataset, then sort descendingly and select the Continent from the top-ranked row.",
        "type": 4,
        "idx": 2320
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM (SELECT \"1982268.0\" AS GNP, Population, Continent FROM country WHERE name = (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) UNION ALL SELECT GNP, Population, Continent FROM country WHERE name != (SELECT A.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE B.name = \"Korla\" ) ) ORDER BY 1.0 * GNP / Population DESC LIMIT 1",
        "englishquestion": "In which continent can we find the country with the highest GNP per capita, if the GNP of the country containing Korla City is 1982268?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Identify the country containing Korla City by joining the `country` and `city` tables, then select its **name**, **Continent**, and **Population** while overriding its GNP with the fixed value `1982268.0`.  【step2】: Combine this overridden GNP record with GNP data from **all other countries** (excluding the one containing Korla City) using `UNION ALL`.  【step3】: Calculate GNP per capita (`GNP/Population`) for all entries in the combined dataset, sort in descending order, and select the **Continent** of the top-ranked entry.",
        "type": 4,
        "idx": 2321
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Among the countries that became independent after 1979, which country has the highest growth rate of GNP?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter countries that gained independence after 1979 using **WHERE IndepYear > 1979**.  【step2】: Calculate the GNP growth rate as **(GNP - GNPOld) / GNPOld** and sort results in descending order by this value.  【step3】: Select the top-ranked country with **LIMIT 1** to return the highest growth rate entry.",
        "type": 2,
        "idx": 2322
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Which country, among those that gained independence after 1979, has the highest gross national product growth rate?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter countries that gained independence after 1979 using `WHERE IndepYear > 1979`.  【step2】: Calculate the GNP growth rate as `1.0 * (GNP - GNPOld) / GNPOld` and sort the results in descending order.  【step3】: Select the top-ranked country with `LIMIT 1` to get the highest growth rate.",
        "type": 2,
        "idx": 2323
    },
    {
        "db_id": "Population",
        "query": "SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = \"Oceania\" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != \"Oceania\" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Among the countries that became independent after 1979, which country has the highest growth rate in GNP if all countries in Oceania have an increase in curretn GNP of 1,000,000?",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a derived table containing all countries, with GNP increased by 1,000,000 for Oceania countries while keeping other continents' GNP unchanged through UNION ALL.  【step2】: Filter countries that gained independence after 1979 (IndepYear > 1979) from the derived table.  【step3】: Calculate growth rate using (GNP - GNPOld)/GNPOld, sort results in descending order, and select the top entry with LIMIT 1.",
        "type": 4,
        "idx": 2324
    },
    {
        "db_id": "Population",
        "query": "SELECT name FROM ( SELECT name , GNP + 1000000 AS GNP , GNPOld , IndepYear FROM country WHERE Continent = \"Oceania\" UNION ALL SELECT name , GNP , GNPOld , IndepYear FROM country WHERE Continent != \"Oceania\" ) WHERE IndepYear > 1979 ORDER BY 1.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Assuming all countries in Oceania have an increase of 1,000,000 in their current GNP, which country among those that gained independence after 1979 has the highest gross national product growth rate?",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a temporary dataset combining all countries. For Oceania countries, increase GNP by 1,000,000 using UNION ALL to merge adjusted Oceania data with unmodified non-Oceania data.  【step2】: Filter the combined dataset to retain only countries with IndepYear > 1979.  【step3】: Calculate growth rate (GNP - GNPOld)/GNPOld for qualified entries, sort descendingly by this rate, and select the top result with LIMIT 1.",
        "type": 4,
        "idx": 2325
    },
    {
        "db_id": "Population",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "englishquestion": "Which country where the majority of people speak English has the highest population density, how many times larger than the country with the lowest population density?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "The density of population is the ratio between the numbers of people to the size of land.",
        "english_step": "【step1】: Identify countries where English is the majority language by joining `countrylanguage` with a subquery that groups countries by their maximum spoken language percentage.  【step2】: Calculate the minimum population density (population/surface area) globally from the `country` table, ensuring the value is positive to avoid division issues.  【step3】: Compute the population density ratio for English-majority countries relative to the minimum density, then sort and limit to show the country with the highest ratio.",
        "type": 3,
        "idx": 2326
    },
    {
        "db_id": "Population",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "englishquestion": "Among the countries in which English is the most spoken language, which country has the highest population density? What is the ratio between the highest and lowest population density?",
        "reasoning_type": "* / C",
        "commonsense_knowledge": "The density of population is the ratio between the numbers of people to the size of land.",
        "english_step": "【step1】: Identify countries where English is the primary language by selecting **CountryCode** from **countrylanguage** where **Language**='English' and grouped by **CountryCode** with the highest **Percentage**.  【step2】: Calculate population density (Population/SurfaceArea *100) for all countries in **country** and determine the global minimum non-zero population density using a subquery.  【step3】: Filter countries from step1, compute the ratio of their population density against the global minimum, then sort by density descending to return the country with the highest density and its ratio.",
        "type": 3,
        "idx": 2327
    },
    {
        "db_id": "Population",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != \"Ireland\" GROUP BY A.CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "englishquestion": "If no one in Ireland speaks English, which country where the majority of people speak English has the highest population density, how many times larger than the country with the lowest population density?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "The density of population is the ratio between the numbers of people to the size of land.",
        "english_step": "【step1】: Filter countries where the primary language is English (excluding Ireland) using a subquery with ROW_NUMBER() to identify the top language per country by percentage.  【step2】: Calculate population density (Population/SurfaceArea) for these filtered countries, and simultaneously find the minimum non-zero population density globally via a subquery.  【step3】: Compute the density ratio (selected country's density ÷ minimum density), then return the country with the highest density and its multiple compared to the lowest density.",
        "type": 4,
        "idx": 2328
    },
    {
        "db_id": "Population",
        "query": "SELECT Name , ( 100.0 * Population / SurfaceArea ) / ( SELECT MIN ( 100.0 * Population / SurfaceArea ) FROM country WHERE 100.0 * Population / SurfaceArea > 0 ) AS times FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT * , MAX ( Percentage ) FROM countrylanguage A JOIN country B ON A.CountryCode = B.Code WHERE B.name != \"Ireland\" GROUP BY A.CountryCode ) WHERE Language = \"English\" ) ORDER BY 100.0 * Population / SurfaceArea DESC LIMIT 1",
        "englishquestion": "If English is not spoken in Ireland, which country among those in which English is the most spoken language has the highest population density? What is the ratio between the highest and lowest population density?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "The density of population is the ratio between the numbers of people to the size of land.",
        "english_step": "【step1】: Filter countries where the primary language is English and exclude Ireland. Use a subquery with ROW_NUMBER() to identify the most spoken language per country (PARTITION BY CountryCode ORDER BY Percentage DESC), retaining only rows where rn=1 and Language='English'.  【step2】: Calculate population density (Population/SurfaceArea *100) for these filtered countries. In parallel, compute the minimum non-zero population density globally via a subquery (SELECT MIN(...) FROM country).  【step3】: Divide the highest density by the minimum density to get the ratio (times), then return the country name and ratio sorted by density descending, limited to the top result.",
        "type": 4,
        "idx": 2329
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "In countries where Arabic is not the official language, which country has the largest increase rate in GNP?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter countries where Arabic is not the official language using a subquery to exclude countries with 'Arabic' as an official language in the countrylanguage table.  【step2】: Calculate the GNP growth rate percentage for remaining countries using the formula ((GNP - GNPOld)/GNPOld)*100.0 and sort them in descending order.  【step3】: Select the country with the highest growth rate by limiting the result to the top entry using LIMIT 1.",
        "type": 2,
        "idx": 2330
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Among countries with non-Arabic official languages, what is the name of the country that has experienced the greatest growth rate in GNP?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter out countries where Arabic is an official language by using a subquery to select CountryCodes from countrylanguage where Language='Arabic' and IsOfficial='T'.  【step2】: Exclude these countries from the main query using NOT IN, then calculate the GNP growth rate as (GNP - GNPOld)/GNPOld * 100 for the remaining countries.  【step3】: Order the results by the calculated growth rate in descending order and select the top result with LIMIT 1 to get the country with the highest growth rate.",
        "type": 2,
        "idx": 2331
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = \"South America\" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != \"South America\" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "Among the countries where Arabic is not the official language, which country has the largest growth rate of GNP if the old GNP of all countries in South America increased by 9999.0?",
        "reasoning_type": "- + * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a derived table combining South American countries (with GNPOld increased by 9999) and non-South American countries (original GNPOld) using UNION ALL.  【step2】: Filter out countries where Arabic is an official language using WHERE Code NOT IN (subquery on countrylanguage).  【step3】: Calculate GNP growth rate percentage ((GNP-GNPOld)/GNPOld*100), sort results in descending order, and select the top entry with LIMIT 1.",
        "type": 4,
        "idx": 2332
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM ( SELECT Name , Code , GNP , GNPOld + 9999.0 AS GNPOld FROM country WHERE Continent = \"South America\" UNION ALL SELECT Name , Code , GNP , GNPOld FROM country WHERE Continent != \"South America\" ) WHERE Code NOT IN ( SELECT CountryCode FROM countrylanguage WHERE Language = \"Arabic\" AND IsOfficial = \"T\" ) ORDER BY 100.0 * ( GNP - GNPOld ) / GNPOld DESC LIMIT 1",
        "englishquestion": "If all South American countries have an increase of 9999.0 in their previous GNP, which country, among those with non-Arabic official languages, has the highest Gross National Product growth rate?",
        "reasoning_type": "- + * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a temporary dataset (sub) combining South American countries with their GNPOld increased by 9999.0 and all other countries retaining original GNPOld values using UNION ALL.  【step2】: Filter out countries where Arabic is an official language by excluding CountryCodes linked to Arabic in countrylanguage (IsOfficial='T').  【step3】: Calculate the GNP growth rate [(GNP - GNPOld)/GNPOld * 100], order results descendingly by growth rate, and return the top-ranked country.",
        "type": 4,
        "idx": 2333
    },
    {
        "db_id": "Population",
        "query": "SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = \"North America\" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "englishquestion": "Which city in North America has a population at least twice that of Kang-won?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total population of all cities in the Kang-won district using the subquery: `(SELECT SUM(Population) FROM city WHERE District = 'Kang-won')`.  【step2】: Perform a JOIN between the `country` and `city` tables, filtering countries in North America with `A.Continent = 'North America'`.  【step3】: Compare each city's population to twice the subquery result using `B.Population >= 2 * [subquery]` and return matching city names.",
        "type": 2,
        "idx": 2334
    },
    {
        "db_id": "Population",
        "query": "SELECT B.name FROM country A JOIN city B ON A.Code = B.CountryCode WHERE A.Continent = \"North America\" AND B.Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "englishquestion": "What North American city has a population that is at least double the population of Kang-won?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Execute the subquery to calculate the total population of cities in the 'Kang-won' district: `SELECT SUM(Population) FROM city WHERE District = 'Kang-won'`.  【step2】: Join the `country` and `city` tables using `CountryCode`, filter by continent `North America`, and reference the subquery result.  【step3】: Compare each North American city's population against twice the subquery result, then output qualifying city names via `B.Population >= 2 * (subquery_result)`.",
        "type": 2,
        "idx": 2335
    },
    {
        "db_id": "Population",
        "query": "SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND C.Language = \"English\" AND C.IsOfficial = \"T\" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND NOT ( C.Language = \"English\" AND C.IsOfficial = \"T\" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "englishquestion": "If the population of North American countries where English is the official language was increased by 1%, which city in North America has a population at least twice that of Kang-won?",
        "reasoning_type": "* + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate adjusted populations (increased by 1%) for cities in North American countries with English as the official language by joining **country**, **city**, and **countrylanguage** tables.  【step2】: Combine these adjusted populations with unmodified populations of other North American cities using **UNION ALL** to create a unified dataset.  【step3】: Filter cities where the population is at least twice the total population of the 'Kang-won' district, using a subquery to calculate Kang-won's population sum and **DISTINCT** to remove duplicates.",
        "type": 4,
        "idx": 2336
    },
    {
        "db_id": "Population",
        "query": "SELECT DISTINCT ( name ) FROM ( SELECT B.name , B.Population * ( 1 + 0.01 ) AS Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND C.Language = \"English\" AND C.IsOfficial = \"T\" UNION ALL SELECT B.name , B.Population FROM country A JOIN city B ON A.Code = B.CountryCode JOIN countrylanguage C ON A.Code = C.CountryCode WHERE A.Continent = \"North America\" AND NOT ( C.Language = \"English\" AND C.IsOfficial = \"T\" ) ) WHERE Population >= 2 * ( SELECT SUM ( Population ) FROM city WHERE District = \"Kang-won\" )",
        "englishquestion": "If all countries in North America with English as the official language experienced a population increase of 1%, what North American city would have a population that is at least double the population of Kang-won?",
        "reasoning_type": "* + H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the total population of all cities in the Kang-won district using a subquery: `SELECT SUM(Population) FROM city WHERE District = 'Kang-won'`.  【step2】: Create a combined dataset via `UNION ALL`, containing:  - Cities from North American countries with English as the official language, with populations increased by 1%  - Cities from other North American countries (without population adjustment).  【step3】: Filter the combined dataset to select distinct city names where the adjusted/unaltered population is at least double the Kang-won district's total population.",
        "type": 4,
        "idx": 2337
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "englishquestion": "Which continent has a GNP growth rate at least 1.5 times that of Africa?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the GNP growth rate for each continent using the formula: (Total GNP - Total GNPOld) / Total GNPOld * 100.  【step2】: Compute the GNP growth rate specifically for Africa with the same formula.  【step3】: Filter continents where their growth rate exceeds 1.5 times Africa's rate via HAVING clause.",
        "type": 2,
        "idx": 2338
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "englishquestion": "Name the continent whose rate of growth of GNP is no less than 1.5 times that of Africa?",
        "reasoning_type": "- * /",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the GNP growth rate percentage for each continent using the formula: (SUM(GNP) - SUM(GNPOld)) / SUM(GNPOld) * 100.  【step2】: Compute the GNP growth rate percentage for Africa using the same formula within a subquery.  【step3】: Filter continents where their growth rate is at least 1.5 times Africa's rate via the HAVING clause, excluding Africa implicitly through comparison.",
        "type": 2,
        "idx": 2339
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "englishquestion": "If the current GNP of countries where the majority of people speak Czech was increased by 0.5%, which continent has a GNP growth rate at least 1.5 times that of Africa?",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify country codes where Czech is the majority language by selecting **CountryCode** with the maximum **Percentage** from **countrylanguage** where **Language = 'Czech'**, grouped by **CountryCode**.  【step2】: Split countries into two groups using **UNION ALL**:  - For countries in the Czech-speaking group, calculate **GNP * 1.005** to simulate a 0.5% increase.  - For others, keep original **GNP**.  【step3】: Group results by **Continent**, compute the growth rate `(SUM(GNP) - SUM(GNPOld)) / SUM(GNPOld) * 100` for each continent, and filter continents where this rate is > 1.5x Africa’s growth rate (calculated via subquery on **country** with **Continent = 'Africa'**).",
        "type": 4,
        "idx": 2340
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM ( SELECT Code , GNP * ( 1 + 0.005 ) AS GNP , GNPOld , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) UNION ALL SELECT Code , GNP , GNPOld , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Czech\" ) ) GROUP BY Continent HAVING 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) > 1.5 * ( SELECT 100.0 * ( SUM ( GNP ) - SUM ( GNPOld ) ) / SUM ( GNPOld ) FROM country WHERE Continent = \"Africa\" )",
        "englishquestion": "Which continent would have a GNP growth rate that is at least 1.5 times greater than Africa if the GNP of countries where Czech is the dominant language increased by 0.5%?",
        "reasoning_type": "+ - * / H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify countries where Czech is the dominant language by selecting the CountryCode with the highest percentage of Czech speakers per country from the countrylanguage table. Adjust their GNP by 0.5%.  【step2】: Combine adjusted GNP data for Czech-speaking countries with unmodified GNP data for non-Czech-speaking countries using UNION ALL, preserving continent information.  【step3】: Calculate each continent's GNP growth rate (using SUM(GNP)-SUM(GNPOld) normalized by SUM(GNPOld)), then compare against 1.5x Africa's equivalent growth rate through a subquery in the HAVING clause.",
        "type": 4,
        "idx": 2341
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "englishquestion": "Which country has a life expectancy no less than 1.5 times that of Zambia?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve Zambia's LifeExpectancy via subquery: `SELECT LifeExpectancy FROM country WHERE name = 'Zambia'`  【step2】: Calculate 1.5 times the retrieved Zambia's LifeExpectancy value.  【step3】: Select countries where LifeExpectancy >= the calculated value from step 2.",
        "type": 2,
        "idx": 2342
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "englishquestion": "What country has an average life expectancy that is at least 1.5 times that of Zambia?",
        "reasoning_type": "*",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Execute the subquery to retrieve Zambia's life expectancy: SELECT LifeExpectancy FROM country WHERE name = 'Zambia'  【step2】: Calculate 1.5 times the retrieved Zambia's life expectancy value  【step3】: Filter countries where LifeExpectancy >= the calculated value from step 2 via the main query: SELECT Name FROM country WHERE LifeExpectancy >= [calculated_value]",
        "type": 2,
        "idx": 2343
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "englishquestion": "If the top 20 countries in terms of per capita GNP in the world has a life expectancy of 90, which country has a life expectancy no less than 1.5 times that of Zambia?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Identify the top 20 countries by per capita GNP and set their LifeExpectancy to 90. Use a subquery to calculate `(GNP / Population)` for ordering and limit results.  【step2】: Combine these top 20 countries (with forced LifeExpectancy=90) and all other countries (retaining their original LifeExpectancy) using `UNION ALL`, creating the temporary table `combined`.  【step3】: Filter the `combined` table to retain countries where LifeExpectancy is at least 1.5 times Zambia's actual LifeExpectancy, obtained via a subquery on the original `country` table.",
        "type": 4,
        "idx": 2344
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM ( SELECT Name , 90 AS LifeExpectancy FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) UNION ALL SELECT Name , LifeExpectancy FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY 1.0 * GNP / Population DESC LIMIT 20 ) ) WHERE LifeExpectancy >= 1.5 * ( SELECT LifeExpectancy FROM country WHERE name = \"Zambia\" )",
        "englishquestion": "Which country has a life expectancy that is at least 1.5 times that of Zambia, given that the top 20 countries in the world with the highest per capita GNP have a life expectancy of 90?",
        "reasoning_type": "* / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Retrieve the top 20 country codes ranked by per capita GNP (GNP divided by Population) in descending order.  【step2】: Combine two datasets using UNION ALL: one assigns a fixed LifeExpectancy of 90 to the top 20 countries, while the other retains original LifeExpectancy values for non-top-20 countries.  【step3】: Filter the combined dataset to select countries where LifeExpectancy is at least 1.5 times Zambia's actual LifeExpectancy value.",
        "type": 4,
        "idx": 2345
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "englishquestion": "In countries where Dutch is not the main language, which country has the largest reduction in GNP?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify countries where Dutch is the primary language by joining the `countrylanguage` table with a subquery that finds the most widely spoken language (MAX(Percentage)) for each country.  【step2】: Filter out these Dutch-speaking countries from the `country` table using the `NOT IN` clause.  【step3】: Calculate the GNP reduction (GNPOld - GNP) for the remaining countries, sort them in descending order of reduction, and select the top result with `LIMIT 1`.",
        "type": 2,
        "idx": 2346
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "englishquestion": "Which country, among those where Dutch is not the primary language, has experienced the most significant decrease in Gross National Product (GNP)?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify countries where Dutch is the primary language by grouping countrylanguage entries, filtering for the highest percentage language per country, and retaining only those with Dutch.  【step2】: Exclude these Dutch-primary-language countries from the main list of countries in the country table.  【step3】: Calculate the GNP decline (GNPOld - GNP) for the remaining countries, sort them in descending order of decline, and select the top result.",
        "type": 2,
        "idx": 2347
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" UNION SELECT Code FROM country WHERE name = \"Aruba\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "englishquestion": "If everyone in Aruba spoke Dutch, in countries where Dutch is not the main language, which country has the largest reduction in GNP?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify countries where Dutch is the primary language by joining the countrylanguage table with a subquery that finds the language with the highest percentage for each country. Filter for Dutch and combine with Aruba's country code via UNION.  【step2】: Exclude these identified countries (Dutch-speaking primary or Aruba) using NOT IN, then calculate the GNP reduction (GNPOld - GNP) for the remaining countries.  【step3】: Order the results by the GNP reduction in descending order and return the top entry (largest reduction).",
        "type": 4,
        "idx": 2348
    },
    {
        "db_id": "Population",
        "query": "SELECT Name FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Dutch\" UNION SELECT Code FROM country WHERE name = \"Aruba\" ) ORDER BY GNPOld - GNP DESC LIMIT 1",
        "englishquestion": "Assuming every person in Aruba speaks Dutch, which country, among those where Dutch is not the primary language, has experienced the most significant decrease in Gross National Product (GNP)?",
        "reasoning_type": "- H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify countries where Dutch is the primary language (using countrylanguage table) and include Aruba. This is done via a subquery:  `SELECT CountryCode FROM (...) WHERE Language='Dutch'`  combined with  `UNION SELECT Code FROM country WHERE name='Aruba'`, creating an exclusion list.  【step2】: Filter out all countries from the main country table that are in the exclusion list using `WHERE Code NOT IN (...)`.  【step3】: Calculate GNP decrease as `(GNPOld - GNP)`, sort results by this value in descending order, and select the top result with `LIMIT 1`.",
        "type": 4,
        "idx": 2349
    },
    {
        "db_id": "Population",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = \"North America\"",
        "englishquestion": "How many more countries in North America than in South America have a declining GNP?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the count of countries in North America where GNP is declining (GNP < GNPOld).  【step2】: Calculate the count of countries in South America where GNP is declining (GNP < GNPOld) using a subquery.  【step3】: Subtract the South America count from the North America count to get the difference (diff).",
        "type": 2,
        "idx": 2350
    },
    {
        "db_id": "Population",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM country WHERE GNP < GNPOld AND Continent = \"North America\"",
        "englishquestion": "What is the difference in the number of countries with a decreasing GNP in North America compared to South America?",
        "reasoning_type": "-",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Calculate the number of countries in North America where GNP < GNPOld using COUNT(*) with filters Continent = 'North America' and GNP < GNPOld.  【step2】: Calculate the number of countries in South America where GNP < GNPOld via a subquery with COUNT(*) and filters Continent = 'South America' and GNP < GNPOld.  【step3】: Subtract the South America count from the North America count using arithmetic operation (COUNT(*) - subquery_result) to get the difference.",
        "type": 2,
        "idx": 2351
    },
    {
        "db_id": "Population",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = \"North America\"",
        "englishquestion": "Suppose the current GNP of the top two most populous countries in North America increases by 2%, how many more countries in North America than in South America have a declining GNP?",
        "reasoning_type": "+ - * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Extract the two most populous North American countries using a subquery:  `SELECT Code FROM country WHERE Continent = 'North America' ORDER BY Population DESC LIMIT 2`  【step2】: Combine two datasets via UNION ALL:  - First dataset: Apply a 2% GNP increase **only** to the top two populous countries (using results from step1).  - Second dataset: Include all other North American countries **without** changing their GNP.  This creates a virtual table `combined` with adjusted/unaltered GNP values.  【step3】: Calculate the difference between:  - Filtered North American countries (from `combined`) where adjusted GNP < GNPOld.  - Pre-filtered South American countries (directly from original table) where GNP < GNPOld.  Subtract the South American count from the North American count to get the final `diff`.",
        "type": 4,
        "idx": 2352
    },
    {
        "db_id": "Population",
        "query": "SELECT COUNT ( * ) - ( SELECT COUNT ( * ) FROM country WHERE GNP < GNPOld AND Continent = \"South America\" ) AS diff FROM ( SELECT Name , GNP * ( 1 + 0.02 ) AS GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) UNION ALL SELECT Name , GNP , GNPOld , Continent FROM country WHERE Continent = \"North America\" AND Code NOT IN ( SELECT Code FROM country WHERE Continent = \"North America\" ORDER BY Population DESC LIMIT 2 ) ) WHERE GNP < GNPOld AND Continent = \"North America\"",
        "englishquestion": "If the two most populated North American countries experience a 2% increase in GNP, what is the difference in the number of countries with a decreasing GNP between North and South America?",
        "reasoning_type": "+ - * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Identify the two most populated North American countries, calculate their GNP with a 2% increase, and keep other North American countries' GNP unchanged via UNION ALL.  【step2】: Create a combined dataset (subquery) containing all North American countries—modified and unmodified—then filter those with decreased GNP (GNP < GNPOld).  【step3】: Subtract the count of South American countries with decreased GNP from the North American count to get the final difference (diff).",
        "type": 4,
        "idx": 2353
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "englishquestion": "Which continent has a per capita GNP growth rate at least two percentage points higher than Europe?",
        "reasoning_type": "+ - * / C",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Calculate the per capita GNP growth rate for all continents by summing GNP, GNPOld, and Population per continent group.  【step2】: Compute Europe's per capita GNP growth rate using a subquery with the same formula (applied only to Europe's aggregated data).  【step3】: Use HAVING clause to filter continents where growth rate ≥ (Europe's rate + 0.02), leveraging the subquery result for comparison.",
        "type": 3,
        "idx": 2354
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM country GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "englishquestion": "Name a continent whose per capita GNP growth rate exceeds Europe by at least two percentage points?",
        "reasoning_type": "+ - * / C",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Calculate total GNP, total GNPOld, and total population for each continent using GROUP BY.  【step2】: Compute the per capita GNP growth rate for each continent by comparing current and old GNP per capita.  【step3】: Filter continents where this growth rate is ≥ (Europe's rate + 0.02) using a subquery to isolate Europe's rate.",
        "type": 3,
        "idx": 2355
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "englishquestion": "If the GNP of the top three countries with the longest life expectancy decreases by 2%, which continent has a per capita GNP growth rate at least two points higher than Europe?",
        "reasoning_type": "+ - * / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Identify the 3 countries with the longest life expectancy using a subquery:  `SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3`  【step2】: Create a derived table combining two datasets:  1. Selected top 3 countries with reduced GNP (2% decrease) via `GNP * (1 - 0.02)`  2. All other countries retaining original GNP values using `UNION ALL`  【step3】: Group results by Continent, calculate per-capita GNP growth rate difference between adjusted GNP and GNPOld, and filter continents meeting the 2%-higher-than-Europe threshold via HAVING clause with subquery for Europe's baseline.",
        "type": 4,
        "idx": 2356
    },
    {
        "db_id": "Population",
        "query": "SELECT Continent FROM ( SELECT name , Continent , GNP * ( 1 - 0.02 ) AS GNP , Population , GNPOld FROM country WHERE Code IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) UNION ALL SELECT name , Continent , GNP , Population , GNPOld FROM country WHERE Code NOT IN ( SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3 ) ) GROUP BY Continent HAVING 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) >= ( SELECT 1.0 * ( SUM ( GNP ) / SUM ( Population ) - SUM ( GNPOld ) / SUM ( Population ) ) / ( SUM ( GNPOld ) / SUM ( Population ) ) FROM country WHERE Continent = \"Europe\" ) + 0.02",
        "englishquestion": "Assuming a 2% decrease in the GNP of the top three countries with the highest life expectancy, which continent has a per capita GNP growth rate that exceeds Europe by at least two points?",
        "reasoning_type": "+ - * / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.",
        "english_step": "【step1】: Identify the top three countries with the highest LifeExpectancy using a subquery: `SELECT Code FROM country ORDER BY LifeExpectancy DESC LIMIT 3`.  【step2】: Create a combined dataset where:  - Top 3 countries have GNP reduced by 2% (via `GNP * (1 - 0.02)`)  - Other countries retain original GNP values  using UNION ALL to merge both groups.  【step3】: Calculate per capita GNP growth rate for each continent using aggregate functions in the outer query. Compare against Europe's growth rate (+2% threshold) via HAVING clause with correlated subquery filtering Europe's baseline growth.",
        "type": 4,
        "idx": 2357
    },
    {
        "db_id": "Population",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = \"Asia\"",
        "englishquestion": "List name, the past and current gross national product of each country in Asia, and estimate the future gross national product if the growth rate remains unchanged.",
        "reasoning_type": "+ -",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter countries in Asia using the WHERE clause to select only those in the 'Asia' continent.  【step2】: Retrieve the name, GNPOld, and GNP columns from the filtered dataset.  【step3】: Calculate GNPFuture by adding the difference between GNP and GNPOld (current growth) to the current GNP, assuming a constant growth rate.",
        "type": 2,
        "idx": 2358
    },
    {
        "db_id": "Population",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM country WHERE Continent = \"Asia\"",
        "englishquestion": "For each country in Asia, provide a list of their name, the past and current GNP, and estimate their future Gross National Product assuming a constant growth rate.",
        "reasoning_type": "+ -",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter countries located in Asia using the WHERE clause.  【step2】: Select the country name, historical GNP (GNPOld), and current GNP (GNP) from the filtered results.  【step3】: Calculate the estimated future GNP (GNPFuture) by adding the difference between current and past GNP (GNP - GNPOld) to the current GNP.",
        "type": 2,
        "idx": 2359
    },
    {
        "db_id": "Population",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) ) WHERE Continent = \"Asia\"",
        "englishquestion": "If the current gross national product of a country with Chinese as its main language is 1000000.0, list name, the past and current gross national product of each country in Asia, and estimate the future gross national product if the growth rate remains unchanged.",
        "reasoning_type": "+ - H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Retrieve countries where Chinese is the primary language by selecting CountryCodes with the highest percentage of Chinese speakers from the countrylanguage table.  【step2】: Create a combined dataset using UNION ALL:  - For Chinese-speaking countries, set current GNP to 1000000.0 while retaining GNPOld.  - For non-Chinese-speaking countries, use their original GNP and GNPOld values.  【step3】: Filter the combined dataset to include only Asian countries, then calculate GNPFuture by projecting GNP growth as GNP + (GNP - GNPOld).",
        "type": 4,
        "idx": 2360
    },
    {
        "db_id": "Population",
        "query": "SELECT name , GNPOld , GNP , GNP + ( GNP - GNPOld ) AS GNPFuture FROM ( SELECT name , GNPOld , 1000000.0 AS GNP , Continent FROM country WHERE Code IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) UNION ALL SELECT name , GNPOld , GNP , Continent FROM country WHERE Code NOT IN ( SELECT CountryCode FROM ( SELECT CountryCode , Language , MAX ( Percentage ) FROM countrylanguage GROUP BY CountryCode ) WHERE Language = \"Chinese\" ) ) WHERE Continent = \"Asia\"",
        "englishquestion": "Assuming that the country with Chinese as its primary language has a current GNP of 1000000.0, provide a list of their name, the past and current GNP for each Asian country, and estimate their future Gross National Product assuming a constant growth rate.",
        "reasoning_type": "+ - H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Extract countries with Chinese as their primary language by identifying CountryCodes where the highest percentage language in `countrylanguage` is 'Chinese'. For these countries, set GNP to 1000000.0 while retaining GNPOld.  【step2】: Combine these Chinese-speaking countries with all other countries (using `UNION ALL`), preserving their original GNP values but filtering out countries where Chinese is the primary language.  【step3】: Filter the combined dataset to include only Asian countries (`Continent = 'Asia'`) and calculate `GNPFuture` by projecting linear growth: `GNP + (GNP - GNPOld)`.",
        "type": 4,
        "idx": 2361
    },
    {
        "db_id": "Population",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = \"United Kingdom\"",
        "englishquestion": "The annual population growth rate in the UK is 0.4%. What is the population size in the UK one year later?",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter the country table to select the row where the name is 'United Kingdom'.  【step2】: Calculate the projected population by multiplying the current **Population** by **1.004** (which represents a 0.4% increase).  【step3】: Assign the alias **population_in_1year** to the calculated result.",
        "type": 2,
        "idx": 2362
    },
    {
        "db_id": "Population",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM country WHERE name = \"United Kingdom\"",
        "englishquestion": "What will be the population size of UK after one year, given that the UK has an annual growth rate of 0.4%?",
        "reasoning_type": "+ *",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter the country table to retrieve the population of the United Kingdom using WHERE name = 'United Kingdom'.  【step2】: Calculate the projected population by multiplying the current population by the growth factor (1 + 0.004).  【step3】: Assign the calculated value to the alias **population_in_1year** using the AS keyword.",
        "type": 2,
        "idx": 2363
    },
    {
        "db_id": "Population",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy <= 75 ) WHERE name = \"United Kingdom\"",
        "englishquestion": "The annual population growth rate in the UK is 0.4%. If the population of countries with a life expectancy greater than 75 in Europe is 103000, what is the population size in the UK one year later?",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Filter European countries into two groups: those with LifeExpectancy >75 (assign Population=103000) and others (keep original Population).  【step2】: Combine both groups using UNION to form a derived table containing all European countries with adjusted/actual populations.  【step3】: Calculate the UK's population growth by applying 0.4% increase to the entry where name='United Kingdom' from the combined results.",
        "type": 4,
        "idx": 2364
    },
    {
        "db_id": "Population",
        "query": "SELECT Population * ( 1 + 0.004 ) AS population_in_1year FROM ( SELECT Continent , name , 103000 AS Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy > 75 UNION SELECT Continent , name , Population FROM country WHERE Continent = \"Europe\" AND LifeExpectancy <= 75 ) WHERE name = \"United Kingdom\"",
        "englishquestion": "What will be the population size of the UK after one year, given that the UK has an annual population growth rate of 0.4% and all European countries with a life expectancy greater than 75 have a population of 103000?",
        "reasoning_type": "+ * H",
        "commonsense_knowledge": "",
        "english_step": "【step1】: Create a temporary table (subquery) containing European countries, assigning a fixed population of 103000 to countries with LifeExpectancy > 75 and retaining original Population values for others.  【step2】: Combine the two filtered datasets (countries with LifeExpectancy > 75 and ≤75) using UNION to form a unified European country list.  【step3】: Filter the subquery for the United Kingdom and calculate its projected population after applying the 0.4% growth rate (Population * 1.004).",
        "type": 4,
        "idx": 2365
    },
    {
        "db_id": "Population",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = \"Zambia\"",
        "englishquestion": "According to Zambia's life expectancy, what is the expected year of death for people born in the year of Zambia's independence?",
        "reasoning_type": "+ C",
        "commonsense_knowledge": "Age is calculated by subtracting date of birth from a given date.",
        "english_step": "【step1】: Filter the country table to retrieve the record where the name is 'Zambia'.  【step2】: Extract the values of the **IndepYear** (independence year) and **LifeExpectancy** columns from the filtered record.  【step3】: Add **IndepYear** and **LifeExpectancy**, then cast the result to an integer to calculate the expected death year.",
        "type": 3,
        "idx": 2366
    },
    {
        "db_id": "Population",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM country WHERE name = \"Zambia\"",
        "englishquestion": "Based on Zambia's life expectancy, what is the predicted year of death for individuals born in the year of it's independence?",
        "reasoning_type": "+ C",
        "commonsense_knowledge": "Age is calculated by subtracting date of birth from a given date.",
        "english_step": "【step1】: Filter the database to retrieve the row where the country name is 'Zambia' using the **WHERE** clause.  【step2】: Access the **IndepYear** (independence year) and **LifeExpectancy** values for Zambia from the selected row.  【step3】: Calculate the predicted death year by adding **IndepYear** and **LifeExpectancy**, then cast the result to an integer using **CAST()** and alias it as **death_year**.",
        "type": 3,
        "idx": 2367
    },
    {
        "db_id": "Population",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) ) ) WHERE name = \"Zambia\"",
        "englishquestion": "If life expectancy increases by 10 years in countries with per capita GNP greater than the average per capita GNP of all European countries, what is the expected year of death for people born in the year of Zambia's independence asccording to Zambia's life expectancy?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.  Age is calculated by subtracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the average per capita GNP of all European countries using a subquery:  `SELECT 1.0 * SUM(GNP)/SUM(Population) FROM country WHERE Continent = 'Europe'`  【step2】: Split countries into two groups via UNION ALL:  - Group 1: Countries with per capita GNP > European average, add 10 years to LifeExpectancy  - Group 2: Other countries retain original LifeExpectancy  【step3】: Filter merged results for Zambia, compute death year by summing IndepYear and adjusted LifeExpectancy:  `CAST(IndepYear + LifeExpectancy AS SIGNED)`",
        "type": 4,
        "idx": 2368
    },
    {
        "db_id": "Population",
        "query": "SELECT CAST ( IndepYear + LifeExpectancy AS INT ) AS death_year FROM ( SELECT name , IndepYear , LifeExpectancy + 10 AS LifeExpectancy FROM country WHERE 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) UNION ALL SELECT name , IndepYear , LifeExpectancy FROM country WHERE NOT ( 1.0 * GNP / Population > ( SELECT 1.0 * SUM ( GNP ) / SUM ( Population ) FROM country WHERE Continent = \"Europe\" ) ) ) WHERE name = \"Zambia\"",
        "englishquestion": "What is the predicted year of death for individuals born during the year of Zambia's independence, according to the country's life expectancy, if countries with a per capita GNP higher than the average per capita GNP of all European countries experience a 10-year increase in life expectancy?",
        "reasoning_type": "+ * / C H",
        "commonsense_knowledge": "GNP per capita is computed by dividing the GNP by the population.  Age is calculated by subtracting date of birth from a given date.",
        "english_step": "【step1】: Calculate the average per capita GNP of all European countries using the inner subquery: `SUM(GNP)/SUM(Population)`.  【step2】: Split countries into two groups via UNION ALL:  - Group 1: Add 10 to LifeExpectancy for countries with per capita GNP > European average.  - Group 2: Keep original LifeExpectancy for others.  【step3】: Filter the combined results for 'Zambia', then compute the death year by adding its IndepYear (independence year) to the adjusted LifeExpectancy.",
        "type": 4,
        "idx": 2369
    }
]